<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	
	<title>SyntaxHighlighter Build Test Page</title>
	<script type="text/javascript" src="scripts/shCore.js"></script>
	<script type="text/javascript" src="scripts/shBrushDiff.js"></script>
	<script type="text/javascript" src="scripts/shBrushPlSql.js"></script>	

	
	<script type="text/javascript">
		
		
	</script>
</head>

<body >
<h1>SyntaxHihglighter Test</h1>
<p>This is a test file to insure that everything is working well.</p>

<pre class="brush: plsql;">
	
/*multiline 
comments*/	

CREATE OR REPLACE Package FC_CRED_PROCEDURES is

  -- Author  : AMS
  -- Created : 16.05.2006 18:41:30
  -- Purpose : Процедуры для использования в кредитной подсистеме

  Type Comm_Bool_Array Is Table Of Boolean Index By Binary_Integer;
  Type Comm_Integer_Array Is Table Of Pls_Integer Index By Binary_Integer;

  m_post_date account_snapshot.snapshot_date%TYPE;

  Procedure Modify_First_Doc_Inbank_Cur(P_Step_Id             In Gen_Template_Step.Id%Type,
                                        P_Action_Id           In Action.Id%Type,
                                        P_Inbank_Cur_Document In Out T_Inbank_Cur_Document,
                                        P_Additional_Params   In Varchar2);

  Procedure Modify_First_Doc_Inbank(P_Step_Id           In Gen_Template_Step.Id%Type,
                                    P_Action_Id         In Action.Id%Type,
                                    P_Inbank_Document   In Out T_Inbank_Document,
                                    P_Additional_Params In Varchar2);

  Procedure Modify_First_Doc_Nonbal_Cur(P_Step_Id                      In Gen_Template_Step.Id%Type,
                                        P_Action_Id                    In Action.Id%Type,
                                        P_Nonbalance_Curorder_Document In Out T_Inbank_Cur_Document,
                                        P_Additional_Params            In Varchar2);

  Procedure Modify_First_Doc_Nonbal(P_Step_Id                   In Gen_Template_Step.Id%Type,
                                    P_Action_Id                 In Action.Id%Type,
                                    P_Nonbalance_Order_Document In Out T_Inbank_Document,
                                    P_Additional_Params         In Varchar2);

  --Функция проверки заполнения финсостояния
  Function Is_Fin_Status_Set(P_Contract_Id Pls_Integer) Return Boolean;

  --Функция проверки заполнения обслуживания долга
  Function Is_Credit_Debt_Set(P_Contract_Id Pls_Integer) Return Boolean;

  --Функция проверки заполнения разрешения на выдачу
  Function Is_Credit_Output_Set(P_Contract_Id Pls_Integer) Return Boolean;

  --Функция проверки наличия графика на закладке графики
  Function Is_Schedule_Present(P_Contract_Id Pls_Integer) Return Boolean;

  --Функция проверки рассчитан ли график погашений
  Function Is_Schedule_Calculated(P_Contract_Id Pls_Integer) Return Boolean;

  --Функция проверки наличия связи с таблицей залогов/поручительств
  Function Is_Pawn_Present(P_Contract_Id Pls_Integer) Return Boolean;

  --Функция простановки статпараметров s032,s080,s260,r013 на кред. счетах (для регламентной процедуры)
  Function Set_Stat_Param(P_Contract_Id Pls_Integer) Return Boolean;

  --Процедура простановки кодов продукта
  Procedure Set_Product_Type(p_id in pls_integer);

  --Процедура открытия кредитного договора
  Procedure On_Credit_Doc_Open(P_Template_Id       In Generator_Template.Id%Type,
                               P_Additional_Params In Varchar2);

  --Процедура простановки статпараметров s032,s080,s260,r013 на кред. счетах (для операции)
  Procedure On_Modify_Stat_Param(P_Template_Id       In Generator_Template.id%type,
                                 P_Additional_Params In Varchar2);

  --Получение суммы единоразовой комиссии (сумма операции)
  Function Get_Mono_Fee_Amount(P_Operation_Id         In Operation.Id%Type,
                               P_Compound_Document_Id In Compound_Document.Id%Type)
    Return Number;

  --получение остатков на счетах комиссии (всех) для суммы операции
  Function Oper$Get_Mono_Fee_Acc_Amount(P_Operation_Id         In Operation.Id%Type,
                                        P_Compound_Document_Id In Compound_Document.Id%Type)
    Return Number;

  --получение остатков на счетах (на шаге генератора по счету кредит) в операции погашения единоразовой комиссии
  Function Gen$Step_Mono_Fee_Acc_Amount(P_Currency_Id In Currency.Id%Type,
                                        P_Amount      In Action.Amount%Type,
                                        P_Step_Id     In Gen_Template_Step.Id%Type,
                                        P_Action_Id   In Action.Id%Type)
    Return Number;

  --Прцедура простановки признака закрытия счета
  Procedure Set_Close_Acc_Mark(P_Template_Id       In Generator_Template.Id%Type,
                               P_Additional_Params In Varchar2);

  --Регламент по закрытию счетов комиссий единоразовых
  --Вешать на ОТКРЫТИЕ!!!! дня
  Procedure RO_Close_Mono_Fee_Accounts(P_Date   Date,
                                       P_Posted Job_End_Day.Is_Posted%Type);

  --регламент по просрочке единоразовой комиссии
  Procedure RO_Mono_Fee_Expire(P_Date   Date,
                               P_Posted Job_End_Day.Is_Posted%Type);

  --открытие счетов единоразовых комиссий и просрочек, если это нужно
  Procedure On_Create_Auto_Open_Fee_Acc(P_Operation_Id         In Operation.Id%Type,
                                        P_Compound_Document_Id In Compound_Document.Id%Type,
                                        P_Operation_No         In Out Action.Operation_No%Type,
                                        P_Action_Amount        In Out Action.Amount%Type,
                                        P_Action_Currency_Id   In Out Action.Currency_Id%Type,
                                        P_Additional_Params    In Varchar2);

  --Проверка участвуют ли счета, привязанные к договору в каких-либо других
  --договорах для вызова из пакетов
  Function Is_Contract_Accounts_Unique(P_Contract_Id Pls_Integer,
                                       Gen_Exception Boolean Default True)
    Return Boolean;

  --Проверка участвуют ли счета, привязанные к договору в каких-либо других
  --договорах для вызова на втором уровне генератора на on_before или on_after
  Procedure Is_Contract_Accounts_Unique(P_Template_Id       In Generator_Template.Id%Type,
                                        P_Additional_Params In Varchar2);

  --занесение в историю параметров % ставок плавающей сетки
  Procedure Save_Interest_Range_To_Params(P_Con_Id Pls_Integer);

  --Удаление договора (удалим записи о плавающих процентных ставках)
  Procedure On_Delete_Open_Doc(P_Id In Base_Action.Id%Type);

  --отмена начисления по плавающей ставке
  Procedure No_Range_Pcnt(P_Template_Id       In Generator_Template.Id%Type,
                          P_Additional_Params In Varchar2);

  --вернем на начисление по плаваюей ставке
  Procedure Yes_Range_Pcnt(P_Template_Id       In Generator_Template.Id%Type,
                           P_Additional_Params In Varchar2);
  --madcap                                  
  --погошение единоразовой комиссии    
  Procedure On_Bef_Get_Mono_Amount(P_Template_Id       In Generator_Template.Id%Type,
                                   P_Additional_Params In Varchar2);

  --Вынос на просрочку единоразовой комиссии
  Function Oper$Get_Mono_Amount_Expire(P_Operation_Id         In Operation.Id%Type,
                                       P_Compound_Document_Id In Compound_Document.Id%Type)
    Return Number;

  --доступная сумма выдачи кредита
  function oper$get_cash_out(p_operation_id         pls_integer,
                             p_compound_document_id pls_integer)
    return number;

  --доп проверка при выдаче кредита
  function gen$get_cash_out(p_currency_id in currency.id%type,
                            p_amount      in action.amount%type,
                            p_step_id     in gen_template_step.id%type,
                            p_action_id   in action.id%type) return number;

  --доступная сумма выдачи кредита
  function oper$get_cash_out_gb(p_operation_id         pls_integer,
                                p_compound_document_id pls_integer)
    return number;

  --доп проверка при выдаче кредита
  function gen$get_cash_out_gb(p_currency_id in currency.id%type,
                               p_amount      in action.amount%type,
                               p_step_id     in gen_template_step.id%type,
                               p_action_id   in action.id%type) return number;

  --end madcap  

  -- Средние для активных остатков (с учетом 0) добавлено ФИК 21,03,2008
  function get_account_rest_avg(p_account_id pls_integer,
                                p_begin_date date,
                                p_end_date   date,
                                p_all_posts  varchar2 := 'F') return number;

  --сумма и сторнирование начисленных % на тело и просроченную часть
  Procedure On_Create_Int_Storno_Total(P_Operation_Id         In Operation.id%Type,
                                       P_Compound_Document_Id In Compound_Action.Compound_Document_Id%Type,
                                       P_Operation_No         In Out Action.Operation_No%Type,
                                       P_Action_Amount        In Out Action.Amount%Type,
                                       P_Action_Currency_Id   In Out Action.Currency_Id%Type,
                                       P_Additional_Params    In Varchar2);

  --Операция обратная сторнированию % вызывается при удалении операции сторнирования
  Procedure On_Delete_Int_Storno_Total(P_Id In Base_Action.Id%Type);

  -- madcap
  --проверка на  наличии "0" остатков на всех счетах, подвязанных к договору, за исключением счета CUSTOMER_ACCOUNT.
  procedure cred_close_after_gen(P_Template_Id       In Generator_Template.id%type,
                                 P_Additional_Params In Varchar2);

  --перевод в статус "Готов к звкрытию" с режимом договора 2-Родительский
  procedure before_ready_close(P_Template_Id       In Generator_Template.id%type,
                               P_Additional_Params In Varchar2);

  --перед удаление операции - Перевод в договора с статус "Готов к звкрытию"
  procedure on_del_ready_close(p_id in base_action.id%type);
  --end madcap      

  --ams согласно СЗ № 7.3-10/953 от 08.10.2008
  --при определенных условиях не проверяем незакрытые дни в календаре
  Procedure On_Before_Close_Doc(P_Template_Id       In Generator_Template.Id%Type,
                                P_Additional_Params In Varchar2);
  --end ams

  --Перенесенные процедуры с пакета cred_test_edil :  19,02,2008   НАЧАЛО
  function check_is_filial(pc in p_contract.var_fullcontract_type%type)
    return number;

  procedure check_on_modify_range(p_template_id       in generator_template.id%type,
                                  p_additional_params in varchar2);

  procedure on_delete_modify_range(p_base_action_id in pls_integer);
  --Перенесенные процедуры с пакета cred_test_edil :  19,02,2008   КОНЕЦ   

  procedure CRED_UPDATE_D5_R011(p_step_id           in gen_template_step.id%type,
                                p_action_id         in action.id%type,
                                p_additional_params in varchar2);

  --madcap (14.11.2007 21:26:51)

  -- Пролонгация кредитного договора с изменением счета остатка
  -- при изменении срочности договора
  procedure on_prolong_doc_acc(p_operation_id         in operation.id%type,
                               p_compound_document_id in compound_action.compound_document_id%type,
                               p_operation_no         in out action.operation_no%type,
                               p_action_amount        in out action.amount%type,
                               p_action_currency_id   in out action.currency_id%type,
                               p_additional_params    in varchar2);

  -- Пролонгация кредитного договора с изменением счета остатка
  -- при изменении срочности договора
  -- !!! НЕ меняется макрос счета остатка
  procedure prolong_doc_acc(p_id           pls_integer,
                            p_end_date     date,
                            p_int          number,
                            p_prolong_date date);

  -- !!! ОЧЕНЬ ВАЖНОЕ ДЕЙСТВИЕ на after_generate операции
  -- для процедуры prolong_doc_acc
  procedure after_gen_prolong_doc_acc(p_template_id       in generator_template.id%type,
                                      p_additional_params in varchar2);

  -- Процедура обратная операции
  -- Пролонгация кредитного договора с изменением счета остатка
  -- при изменении срочности договора
  procedure prolong_doc_acc_del(p_base_action_id pls_integer);
  --end madcap    

  --madcap (04.04.2008 15:17:02)
  --Выравнивание 9129 (вынесены в наш пакет чтобы не накрывались СР-кими)

  function oper_am$9129(p_operation_id         pls_integer,
                        p_compound_document_id pls_integer) return number;

  function oper_am$9129_multi(p_operation_id         pls_integer,
                              p_compound_document_id pls_integer)
    return number;

  function oper_am$9129_multi_$$$(p_operation_id         pls_integer,
                                  p_compound_document_id pls_integer)
    return number;
  --end madcap

  --madcap (15.12.07 21:52:59)
  --Операция FC_CRED_OVER_MOVE_ACC вынос овердрафта на счета просрочки в связи с арестом счета
  --открывает счета просрочки CREDIT_REST_2 CREDIT_INT_2
  Procedure On_Create_cred_over_move(P_Operation_Id         In Operation.id%Type,
                                     P_Compound_Document_Id In Compound_Action.Compound_Document_Id%Type,
                                     P_Operation_No         In Out Action.Operation_No%Type,
                                     P_Action_Amount        In Out Action.Amount%Type,
                                     P_Action_Currency_Id   In Out Action.Currency_Id%Type,
                                     P_Additional_Params    In Varchar2);

  --возвращает в назначение счет процентов
  function get_acc_rest_number return varchar2;

  --возвращает в назначение счет остатка
  function get_acc_int_number return varchar2;

  --Простановка новых счетов остатка и процентов
  procedure after_cred_over_move(P_Template_Id       In Generator_Template.id%type,
                                 P_Additional_Params In Varchar2);

  -- откат операции FC_CRED_OVER_MOVE_ACC
  procedure on_del_cred_over_move_acc(p_id in base_action.id%type);

  --end madcap 

  --madcap (20.01.08 16:45:10)
  --Регламентная операция Проставить R011 для счетов начисленных доходов в зависимости от вида задолженности
  procedure RO_set_r011(P_Date Date, P_Posted Job_End_Day.Is_Posted%Type);
  --end madcap

  --madcap (28.04.08 10:46:29)
  procedure on_before_change_acc(P_Template_Id       In Generator_Template.id%type,
                                 P_Additional_Params In Varchar2);

  -- откат операции FC_CRED_CHANGE_ACC
  procedure on_del_cred_change_acc(p_id in base_action.id%type);

  --переброска средств на другой счет через 2909
  --вызывает операцию FC_CRED_MOVE_AMOUNT_2909
  procedure exec_move_amount_2909(p_action_id          out action.id%type,
                                  p_contract_id        in contract.id%type,
                                  p_date               in date,
                                  p_account_tranzit_id in account.id%type,
                                  p_account_debit_id   in account.id%type,
                                  p_account_credit_id  in account.id%type,
                                  p_amount             in document.amount%type,
                                  p_description        in document.description%type);

  -- процедура установки параметров документа для операции FC_CRED_MOVE_AMOUNT_2909
  -- процедура установки параметров документа для валютной проводки
  procedure set_acc_on_document(p_step_id             in gen_template_step.id%TYPE,
                                p_action_id           in action.id%TYPE,
                                p_inbank_cur_document in out T_INBANK_CUR_DOCUMENT,
                                p_additional_params   in varchar2);

  -- процедура установки параметров документа для операции FC_CRED_MOVE_AMOUNT_2909
  procedure set_acc_on_document(p_step_id           in gen_template_step.id%TYPE,
                                p_action_id         in action.id%TYPE,
                                p_inbank_document   in out T_INBANK_DOCUMENT,
                                p_additional_params in varchar2);
  --end madcap

  -- Праставить на договоре начальную сумму дисконта
  procedure on_update_amount_discont(p_template_id       in generator_template.id%type,
                                     p_additional_params in varchar2);

  -- Проверка на повторяемость выполнения операции - Выдача кредита на р/счет (за вычетом дисконта)                                     
  procedure on_calc_discont_ns(p_operation_id         in operation.id%type,
                               p_compound_document_id in compound_action.compound_document_id%type,
                               p_operation_no         in out action.operation_no%type,
                               p_action_amount        in out action.amount%type,
                               p_action_currency_id   in out action.currency_id%type,
                               p_additional_params    in varchar2);
  procedure on_calc_discont(p_operation_id         in operation.id%type,
                            p_compound_document_id in compound_action.compound_document_id%type,
                            p_operation_no         in out action.operation_no%type,
                            p_action_amount        in out action.amount%type,
                            p_action_currency_id   in out action.currency_id%type,
                            p_additional_params    in varchar2);
  Procedure On_Create_Calc_SYS_CUST(p_operation_id         in operation.id%type,
                                    p_compound_document_id in compound_action.compound_document_id%type,
                                    p_operation_no         in out action.operation_no%type,
                                    p_action_amount        in out action.amount%type,
                                    p_action_currency_id   in out action.currency_id%type,
                                    p_additional_params    in varchar2);

  procedure on_calc_depo_discont_ns(p_operation_id         in operation.id%type,
                                    p_compound_document_id in compound_action.compound_document_id%type,
                                    p_operation_no         in out action.operation_no%type,
                                    p_action_amount        in out action.amount%type,
                                    p_action_currency_id   in out action.currency_id%type,
                                    p_additional_params    in varchar2);

  --madcap (15.07.08 15:30:28)
  --Простановка стат параметров(S040, S050, S180, S181, S183)
  --на счет исходя из указаной даты начала договора и даты окончания
  procedure set_stat_param_to_acc(p_account_id account.id%type,
                                  p_begin_date date,
                                  p_end_date   date);
  --end madcap  

  procedure on_create_add_int(p_template_id       in generator_template.id%type,
                              p_additional_params in varchar2);

  -----
  procedure on_create_add_comiss(p_template_id       in generator_template.id%type,
                                 p_additional_params in varchar2);

  procedure spis_arest(p_template_id       in generator_template.id%type,
                       p_additional_params in varchar2);
  -- Операция обратная списанию по постановлению в инвалюте 
  procedure on_del_arest_spis(p_base_action_id in base_action.id%type);

  function oper_am$arest_amount(p_operation_id         pls_integer,
                                p_compound_document_id pls_integer)
    return number;

  --Kravchenko A.V. (14.11.08 12:04:30)
  --Перегруженая операция из D_CREDIT_GENERATOR 
  --для возможности пересчета графиков по договорам ГИУ
  procedure on_create_recalc_payment_new(p_template_id       in generator_template.id%type,
                                         p_additional_params in varchar2);

  --end Kravchenko A.V.                                

  --ams 23.01.2009
  --запрет выполнения "старой" операции начисления комиссии над "новыми" договорами
  --старая операция выполняется ТОЛЬКО над договорами, с датой начала меньше 01.01.2009
  Procedure Stop_Exec_Old_Operation(P_Template_Id       In Generator_Template.Id%Type,
                                    P_Additional_Params In Varchar2);
  --end ams

  --Kravchenko A.V. (26.01.09 12:11:01)
  --Начисление процентов (проверки)
  function gen$check_calc_int(p_currency_id in currency.id%type,
                              p_amount      in action.amount%type,
                              p_step_id     in gen_template_step.id%type,
                              p_action_id   in action.id%type) return number;
  --end Kravchenko A.V.

  --ams 27.01.2009
  --Получениесуммы комиссии для новой операции
  Procedure On_Create_Get_Commiss_Sum(P_Operation_Id         In Operation.Id%Type,
                                      P_Compound_Document_Id In Compound_Action.Compound_Document_Id%Type,
                                      P_Operation_No         In Out Action.Operation_No%Type,
                                      P_Action_Amount        In Out Action.Amount%Type,
                                      P_Action_Currency_Id   In Out Action.Currency_Id%Type,
                                      P_Additional_Params    In Varchar2);

  --закрытие этапов по комиссии при начислении
  Procedure On_After_Gen_New_Commiss(P_Template_Id       In Generator_Template.Id%Type,
                                     P_Additional_Params In Varchar2);

  --Откат операции начисления комиссии
  Procedure On_Delete_New_Commiss(P_Base_Action_Id In Base_Action.Id%Type);

  --перерасчет графика по комиссии на новое правило начисления комиссии
  Procedure On_After_Gen_Calc_Payment(P_Template_Id       In Generator_Template.Id%Type,
                                      P_Additional_Params In Varchar2);
  --end ams

  --Kravchenko A.V. (06.02.09 15:56:43)
  -- Установка ответственного сотрудника
  procedure on_before_set_owner(p_template_id       in generator_template.id%type,
                                p_additional_params in varchar2);

  -- Откат установки ответственного сотрудника
  procedure on_delete_set_owner(p_action_id in base_action.id%type);

  --end Kravchenko A.V.

  --Kravchenko A.V. (17.02.09 18:42:07)
  -- настройка счетов на новом типе перед изменением типа договора
  procedure on_before_remove_type(p_template_id       in generator_template.id%type,
                                  p_additional_params in varchar2);
  --end Kravchenko A.V. 

  --Kravchenko A.V. (23.02.09 12:47:13)
  -- Возвращает ID счета резерва 2400 для списания кредита за счет резерва
  -- p_type = 'INT' для доходов, 'REST' для тела
  -- p_currency_id валюта счета для доходов
  function get_acc_id_rezerv(p_contract_id contract.id%type,
                             p_type        varchar2,
                             p_currency_id currency.id%type default null)
    return account.id%type;

  -- Списание кредита за счет страхового резерва
  procedure on_create_cred_charge_off(p_operation_id         in operation.id%type,
                                      p_compound_document_id in compound_action.compound_document_id%type,
                                      p_operation_no         in out action.operation_no%type,
                                      p_action_amount        in out action.amount%type,
                                      p_action_currency_id   in out action.currency_id%type,
                                      p_additional_params    in varchar2);

  -- Списание кредита за счет резервов
  -- Проставление параметров на документах после генерации
  procedure on_after_cred_charge_off(p_template_id       in generator_template.id%type,
                                     p_additional_params in varchar2);

  -- Откат операции по списания кредита за счет резервов
  procedure on_delete_cred_charge_off(p_action_id in base_action.id%type);

  -- процедура установки параметров документа для
  -- обычной гривневой проводки 
  procedure on_step_gen_set_acc(p_step_id           in gen_template_step.id%TYPE,
                                p_action_id         in action.id%TYPE,
                                p_inbank_document   in out T_INBANK_DOCUMENT,
                                p_additional_params in varchar2);

  procedure on_step_gen_set_acc(p_step_id             in gen_template_step.id%type,
                                p_action_id           in action.id%type,
                                p_inbank_cur_document in out T_INBANK_CUR_DOCUMENT,
                                p_additional_params   in varchar2);
  --end Kravchenko A.V.    
  -- edil
  function gen$CRED_TO_FX_EQV (
      p_currency_id in currency.id%type,
      p_amount in action.amount%type,
      p_step_id in gen_template_step.id%type,
      p_action_id in action.id%type
     ) return number;

  procedure add_fx_request(p_operation_id         pls_integer,
                           p_compound_document_id pls_integer,
                           p_operation_no         varchar2,
                           p_action_amount        number,
                           p_action_currency_id   pls_integer,
                           p_additional_params    varchar2);
  procedure on_del_add_fx_request(p_id in pls_integer);
  -- edil

  -- Kravchenko A.V. (12.03.09 17:06:41)
  -- Возвращает ID S260 по ID счета и контракта из таблицы FC_BANK_PRODUCT_ATTR 
  -- если не передавать контракт или нет соответствия в FC_BANK_PRODUCT_ATTR то 
  -- будем искать только по стат параметрам контрагента
  function get_s260_id_by_acc_id(p_account_id account.id%type,
                                 p_contract_id contract.id%type default null,
                                 p_must_exists varchar2 default 'T') return kl_s260.id%type;

  --Возвращает s260 по ID договора
  function get_s260_id_by_con_id(p_contract_id contract.id%type,
                                 p_must_exists varchar2 default 'T') return kl_s260.id%type;
  --end Kravchenko A.V.
  --Возвращает r013 по ID договора
  function get_r013_id_by_acc_id(p_contract_id contract.id%type default null,
                                 p_account_id account.id%type,
                                 p_must_exists varchar2 default 'T') return kl_r013.id%type;                                 
  function get_r011_id_by_acc_id(p_contract_id contract.id%type default null,
                                 p_account_id account.id%type,
                                 is_overdue boolean,
                                 p_must_exists varchar2 default 'T') return kl_r011.id%type;
  -- Kravchenko A.V. (22.07.09 15:06:45)
  -- Установка ответственного сотрудника за погашение
  procedure on_before_set_owner_pro(p_template_id       in generator_template.id%type,
                                    p_additional_params in varchar2);
                                    
  -- Откат установки ответственного сотрудника за погашение
  procedure on_delete_set_owner_pro(p_action_id in base_action.id%type);

  -- Установка прогнозных сумм ответственного сотрудника за погашение
  procedure on_before_set_amount_pro(p_template_id       in generator_template.id%type,
                                    p_additional_params in varchar2);
                                    
  -- Откат установки прогнозных сумм ответственного сотрудника за погашение
  procedure on_delete_set_amount_pro(p_action_id in base_action.id%type);

  --end Kravchenko A.V.      

  procedure spis_arest_multi(p_template_id       in generator_template.id%type,
                             p_additional_params in varchar2);
  procedure on_step_after_set_D020(
    p_step_id           in  gen_template_step.id%type,
    p_action_id         in  action.id%type,
    p_additional_params in  varchar2
   );
 procedure after_gen_out_cred(p_template_id       in generator_template.id%type,
                                      p_additional_params in varchar2); 
                                      
 procedure on_delete_set_F3(p_action_id in base_action.id%type);                                       

  -- Откат при изменении % ставки на дату
  procedure on_delete_modify_int(p_base_action_id in base_action.id%type);
  
  --Изменение графика в датах погашения
  Procedure Set_Need_Date_To_Schedule(P_Template_Id In Generator_Template.Id%Type,
                                      P_Additional_Params In Varchar2);    
End FC_CRED_PROCEDURES;
/
CREATE OR REPLACE Package Body FC_CRED_PROCEDURES Is

  type t_list_acc is table of account.id%type index by binary_integer;

  --используюся для передачи в операцию(FC_MOVE_AMOUNT_2909) счетов кредита и дебета
  g_account_tranzit_id account.id%type;
  g_account_debit_id   account.id%type;
  g_account_credit_id  account.id%type;
  g_description        document.description%type;

  g_account_list t_list_acc;

  Procedure Modify_First_Doc_Inbank_Cur(P_Step_Id             In Gen_Template_Step.Id%Type,
                                        P_Action_Id           In Action.Id%Type,
                                        P_Inbank_Cur_Document In Out T_Inbank_Cur_Document,
                                        P_Additional_Params   In Varchar2) Is
    --Получение первого документа операции
    Cursor Get_First_Document_Note Is
      Select D.Note, D.Id
        From Document D
       Where D.Action_Id = P_Action_Id
       Order By D.Id;
    P_First_Document_Note Get_First_Document_Note%RowType;
    Cursor Get_Acc_No(P_Id Pls_Integer) Is
      Select A.Account_Number From Account A Where A.Id = P_Id;
    P_Acc_No Get_Acc_No%RowType;
  Begin
    Open Get_First_Document_Note;
    Fetch Get_First_Document_Note
      Into P_First_Document_Note;
    If Not (Get_First_Document_Note%NotFound) Then
      If P_Inbank_Cur_Document.Amount <> 0 Then
        Open Get_Acc_No(P_Inbank_Cur_Document.Account_Credit_Id);
        Fetch Get_Acc_No
          Into P_Acc_No;
        If Not (Get_Acc_No%NotFound) Then
          Update Document Doc
             Set Doc.Note = substr(P_First_Document_Note.Note ||
                                   P_Acc_No.Account_Number || '-' ||
                                   To_Char(P_Inbank_Cur_Document.Amount,
                                           'FM999999999999990.00') || '; ',1,255)
           Where Doc.Id = P_First_Document_Note.Id;
        End If;
        Close Get_Acc_No;
      End If;
    End If;
    Close Get_First_Document_Note;
  End Modify_First_Doc_Inbank_Cur;

  Procedure Modify_First_Doc_Inbank(P_Step_Id           In Gen_Template_Step.Id%Type,
                                    P_Action_Id         In Action.Id%Type,
                                    P_Inbank_Document   In Out T_Inbank_Document,
                                    P_Additional_Params In Varchar2) Is
    --Получение первого документа операции
    Cursor Get_First_Document_Note Is
      Select D.Note, D.Id
        From Document D
       Where D.Action_Id = P_Action_Id
       Order By D.Id;
    P_First_Document_Note Get_First_Document_Note%RowType;
    Cursor Get_Acc_No(P_Id Pls_Integer) Is
      Select A.Account_Number From Account A Where A.Id = P_Id;
    P_Acc_No Get_Acc_No%RowType;
  Begin
    Open Get_First_Document_Note;
    Fetch Get_First_Document_Note
      Into P_First_Document_Note;
    If Not (Get_First_Document_Note%NotFound) Then
      If P_Inbank_Document.Amount <> 0 Then
        Open Get_Acc_No(P_Inbank_Document.Account_Credit_Id);
        Fetch Get_Acc_No
          Into P_Acc_No;
        If Not (Get_Acc_No%NotFound) Then
          Update Document Doc
             Set Doc.Note = substr(P_First_Document_Note.Note ||
                                   P_Acc_No.Account_Number || '-' ||
                                   To_Char(P_Inbank_Document.Amount,
                                           'FM999999999999990.00') || '; ',1,255)
           Where Doc.Id = P_First_Document_Note.Id;
        End If;
        Close Get_Acc_No;
      End If;
    End If;
    Close Get_First_Document_Note;
  End Modify_First_Doc_Inbank;

  Procedure Modify_First_Doc_Nonbal_Cur(P_Step_Id                      In Gen_Template_Step.Id%Type,
                                        P_Action_Id                    In Action.Id%Type,
                                        P_Nonbalance_Curorder_Document In Out T_Inbank_Cur_Document,
                                        P_Additional_Params            In Varchar2) Is
    --Получение первого документа операции
    Cursor Get_First_Document_Note Is
      Select D.Note, D.Id
        From Document D
       Where D.Action_Id = P_Action_Id
       Order By D.Id;
    P_First_Document_Note Get_First_Document_Note%RowType;
    Cursor Get_Acc_No(P_Id Pls_Integer) Is
      Select A.Account_Number From Account A Where A.Id = P_Id;
    P_Acc_No Get_Acc_No%RowType;
  Begin
    Open Get_First_Document_Note;
    Fetch Get_First_Document_Note
      Into P_First_Document_Note;
    If Not (Get_First_Document_Note%NotFound) Then
      If P_Nonbalance_Curorder_Document.Amount <> 0 Then
        Open Get_Acc_No(P_Nonbalance_Curorder_Document.Account_Credit_Id);
        Fetch Get_Acc_No
          Into P_Acc_No;
        If Not (Get_Acc_No%NotFound) Then
          Update Document Doc
             Set Doc.Note = substr(P_First_Document_Note.Note ||
                                   P_Acc_No.Account_Number || '-' ||
                                   To_Char(P_Nonbalance_Curorder_Document.Amount,
                                           'FM999999999999990.00') || '; ',1,255)
           Where Doc.Id = P_First_Document_Note.Id;
        End If;
        Close Get_Acc_No;
      End If;
    End If;
    Close Get_First_Document_Note;
  End Modify_First_Doc_Nonbal_Cur;

  Procedure Modify_First_Doc_Nonbal(P_Step_Id                   In Gen_Template_Step.Id%Type,
                                    P_Action_Id                 In Action.Id%Type,
                                    P_Nonbalance_Order_Document In Out T_Inbank_Document,
                                    P_Additional_Params         In Varchar2) Is
    --Получение первого документа операции
    Cursor Get_First_Document_Note Is
      Select D.Note, D.Id
        From Document D
       Where D.Action_Id = P_Action_Id
       Order By D.Id;
    P_First_Document_Note Get_First_Document_Note%RowType;
    Cursor Get_Acc_No(P_Id Pls_Integer) Is
      Select A.Account_Number From Account A Where A.Id = P_Id;
    P_Acc_No Get_Acc_No%RowType;
  Begin
    Open Get_First_Document_Note;
    Fetch Get_First_Document_Note
      Into P_First_Document_Note;
    If Not (Get_First_Document_Note%NotFound) Then
      If P_Nonbalance_Order_Document.Amount <> 0 Then
        Open Get_Acc_No(P_Nonbalance_Order_Document.Account_Credit_Id);
        Fetch Get_Acc_No
          Into P_Acc_No;
        If Not (Get_Acc_No%NotFound) Then
          Update Document Doc
             Set Doc.Note = substr(P_First_Document_Note.Note ||
                                   P_Acc_No.Account_Number || '-' ||
                                   To_Char(P_Nonbalance_Order_Document.Amount,
                                           'FM999999999999990.00') || '; ',1,255)
           Where Doc.Id = P_First_Document_Note.Id;
        End If;
        Close Get_Acc_No;
      End If;
    End If;
    Close Get_First_Document_Note;
  End Modify_First_Doc_Nonbal;

  --Функция проверки заполнения финсостояния
  Function Is_Fin_Status_Set(P_Contract_Id Pls_Integer) Return Boolean Is
    Cursor Check_Cur(P_Id Pls_Integer) Is
      Select CI.Credit_Stan_Id From Credit_Info CI Where CI.Id = P_Id;
    P_Param_Id Pls_Integer;
  Begin
    P_Param_Id := Null;
    Open Check_Cur(P_Contract_Id);
    Fetch Check_Cur
      Into P_Param_Id;
    Close Check_Cur;
    Return P_Param_Id Is Not Null;
  End;

  --Функция проверки заполнения обслуживания долга
  Function Is_Credit_Debt_Set(P_Contract_Id Pls_Integer) Return Boolean Is
    Cursor Check_Cur(P_Id Pls_Integer) Is
      Select CI.Credit_Borg_Id From Credit_Info CI Where CI.Id = P_Id;
    P_Param_Id Pls_Integer;
  Begin
    P_Param_Id := Null;
    Open Check_Cur(P_Contract_Id);
    Fetch Check_Cur
      Into P_Param_Id;
    Close Check_Cur;
    Return P_Param_Id Is Not Null;
  End;

  --Функция проверки заполнения разрешения на выдачу
  Function Is_Credit_Output_Set(P_Contract_Id Pls_Integer) Return Boolean Is
    Cursor Check_Cur(P_Id Pls_Integer) Is
      Select CI.Credit_Output_Id From Credit_Info CI Where CI.Id = P_Id;
    P_Param_Id Pls_Integer;
  Begin
    P_Param_Id := Null;
    Open Check_Cur(P_Contract_Id);
    Fetch Check_Cur
      Into P_Param_Id;
    Close Check_Cur;
    Return P_Param_Id Is Not Null;
  End;

  --Функция проверки наличия графика на закладке графики
  Function Is_Schedule_Present(P_Contract_Id Pls_Integer) Return Boolean Is
    Cursor Check_Cur(P_Id Pls_Integer) Is
      Select CI.Scheduler_Id
        From Contract_Scheduler CI
       Where CI.Contract_Id = P_Id;
    P_Param_Id Pls_Integer;
  Begin
    P_Param_Id := Null;
    Open Check_Cur(P_Contract_Id);
    Fetch Check_Cur
      Into P_Param_Id;
    Close Check_Cur;
    Return P_Param_Id Is Not Null;
  End;

  --Функция проверки рассчитан ли график погашений
  Function Is_Schedule_Calculated(P_Contract_Id Pls_Integer) Return Boolean Is
    Cursor Check_Cur(P_Id Pls_Integer) Is
      Select Count(PS.Id)
        From Payment_Schedule PS
       Where PS.Contract_Id = P_Id;
    P_Param_Id Pls_Integer;
  Begin
    If Not (Is_Schedule_Present(P_Contract_Id)) Then
      --если график на договор не настроен - то и рассчитывать нечего
      --(считаем, что рассчитан)
      Return(True);
    Else
      Open Check_Cur(P_Contract_Id);
      Fetch Check_Cur
        Into P_Param_Id;
      Close Check_Cur;
      Return P_Param_Id > 0;
    End If;
  End;

  --Функция проверки наличия связи с таблицей залогов/поручительств
  Function Is_Pawn_Present(P_Contract_Id Pls_Integer) Return Boolean Is
    Cursor Check_Cur(P_Id Pls_Integer) Is
      Select Count(CP.Id)
        From Credit_Pawn CP
       Where CP.Credit_Document_Id = P_Id;
    P_Param_Id Pls_Integer;
  Begin
    Open Check_Cur(P_Contract_Id);
    Fetch Check_Cur
      Into P_Param_Id;
    Close Check_Cur;
    Return P_Param_Id > 0;
  End;

  -- added by Эdil 05/02/2007
  procedure Set_Product_Type(p_id in pls_integer)
  /*==============================================================
    (c)&(p) Эdil 29/01/2007
    1.Для обеспечения формирования отчетов на Хранилище в разрезе бизнесов (корпоративного, малого, индивидуального) необходимо предусмотреть в закладке "доппараметр" счетов поле "код продукта".
    2.Для всех счетов, привязанных  к договорам кредитной подсистемы:
     - заполнить поле "код продукта" значением поля "код продукта" (Справочник PRODUCT) на типе договора.
     - eсли поле "признак функциональности" (закладка "доппараметры") договора 'Ф' или 'О', то для счетов таких контрактов дополнительно заполнить поле "доходы-расходы по отделам" значением 154002, что будет соответствовать виду бизнеса  "S" - системный.  Если значение поля равно 'V', то поле "доходы-расходы по отделам" заполнить значением 154001.
    ==============================================================*/
  
   is
    p_macro_array   p_utils.idarraytype; -- Массив id макросов
    p_account_array p_utils.idarraytype; -- Массив id счетов
  
    p_macro        generator_acc_macro.sys_name%type;
    p_product_type contract_type.bank_product_id%type;
  
    p_pr_funct        FC_spr_functional_sign.code%type;
    p_move_bank_div_S fc_move_bank_div.id%type;
    p_move_bank_div_V fc_move_bank_div.id%type;
    m_move_bank_div   fc_move_bank_div.id%type;
    p_result          integer;
  
    cursor get_pr_funct(p_id in pls_integer) is
      select sfs.code as pr_funct
        from credit_document_attr cda, FC_spr_functional_sign sfs
       where cda.id = p_id
         and cda.pr_funct = sfs.id;
    cursor get_acc_group(p_acc_id pls_integer) is
      select ag.code
        from account_no a, account_group ag
       where a.account_id = p_acc_id
         and a.account_group_id = ag.id;
    m_acc_group_code account_group.code%type;
  
  begin
    dbms_output.put_line('--begin process at ' ||
                         to_char(sysdate, 'dd.mm.yyyy # hh24:mi:ss'));
  
    -- получить тип системного вида бизнеса для системщиков
    select id
      into p_move_bank_div_S
      from fc_move_bank_div
     where code = '154002'; -- "S"
    select id
      into p_move_bank_div_V
      from fc_move_bank_div
     where code = '154001'; -- "V"
  
    for p_cr in (select id from credit_document cd where cd.id = p_id) loop
      --     dbms_output.put_line(p_cr.id);
      --  получить код продукта с настроек типов контрактов
      select ct.bank_product_id
        into p_product_type
        from contract c, contract_type ct
       where c.id = p_cr.id
         and c.type_id = ct.id;
    
      -- получить признак функционльности с договора: есть или нет
      --!!!!!!!!!!!!!!!!!!!!!!
      p_pr_funct := null;
      open get_pr_funct(p_cr.id);
      fetch get_pr_funct
        into p_pr_funct;
      close get_pr_funct;
      if p_pr_funct is null then
        m_move_bank_div := null;
      else
        if p_pr_funct = 'V' then
          m_move_bank_div := p_move_bank_div_V;
        else
          m_move_bank_div := p_move_bank_div_S;
        end if;
      end if;
      --dbms_output.put_line(p_utils.format_string('pr_funct: %s, div: %s',p_pr_funct, m_move_bank_div));
      -- по локальным макросам
      p_result := p_contract.load_local_account_array(p_id            => p_cr.id,
                                                      p_macro_array   => p_macro_array,
                                                      p_account_array => p_account_array);
      for i in 1 .. p_macro_array.count loop
        -- определить системное имя макроса
        select gam.sys_name
          into p_macro
          from generator_acc_macro gam
         where gam.id = p_macro_array(i);
        open get_acc_group(p_account_array(i));
        fetch get_acc_group
          into m_acc_group_code;
        close get_acc_group;
      
        if p_macro not like '%CUST%' and m_acc_group_code <> '610' then
          begin
            update account_attr aa
               set aa.fc_product_type     = p_product_type,
                   aa.fc_move_bank_div_id = m_move_bank_div
             where aa.id = p_account_array(i);
            if sql%rowcount = 0 then
              insert into account_attr
                (id, fc_product_type, fc_move_bank_div_id)
              values
                (p_account_array(i), p_product_type, m_move_bank_div);
            end if;
          exception
            when others then
              --dbms_output.put_line('some errors occured while processing :'||p_cr.id||':'||p_macro_array(i)||':'||p_account_array(i)||'('||p_macro||')');
              null;
          end;
        end if;
      end loop;
    end loop;
  end set_product_type;

--Функция простановки статпараметров s032,s080,s260,r013 на кред. счетах (для регламентной процедуры)
--Простановка статпараметров s030,s031,s032 со счета залога на сч. остатка,%,комис,дисконта(файл D5) --GES 21.06.07
--Простановка статпараметра s260 (файл D5) --Kravchenko A.V. 05.11.09
--Простановка статпараметра r013           --lds 08г.  ges 09.11.09
--Простановка статпараметров s080,s081     --lds 11-2009
  function Set_Stat_Param(p_contract_id pls_integer) return boolean is
    f_contract_id   pls_integer; -- id родительского контракта
    p_result        integer;
    p_count_S031    pls_integer;
    p_r013_code  kl_r013.code%type;        
    p_s031_code     kl_s031.code%type := null;
    p_is_pawn       char(1);
    
    m_kl_s260_id kl_s260.id%type;
    p_r013_id kl_r013.id%type;
    m_kl_r013_id kl_r013.id%type;
    m_kl_s080_id kl_s080.id%type;
    m_kl_s081_id kl_s081.id%type;
    m_kl_s030_id kl_s030.id%type;
    m_kl_s031_id kl_s031.id%type;
    m_kl_s032_id kl_s032.id%type;
            
    cursor is_line(c_contract_id pls_integer) is -- режим договора
    select c.contract_mode, c.parent_id
      from contract c
     where c.id = c_contract_id
     and c.close_date is null;
    is_line_rec is_line%rowtype;
  
    cursor get_has_pawn(c_contract_id pls_integer) is --имеет ли залоги?
    select decode(count(cp.id), 0, 'F', 1, 'T', 'M') is_pawn
      from credit_pawn cp, 
           compound_document cd, 
           pawn_contract p
     where cp.credit_document_id = c_contract_id
       and cd.id = cp.pawn_contract_id
       and cd.status <> 'CLOSED'
       and cd.status <> 'VACANT'
       and cp.pawn_contract_id = p.id
       and p.pawn_account_id is not null;
  
    cursor get_s031(c_contract_id pls_integer) is --s031 (со счета залога)
    select distinct k.code
      from compound_document cd,
           pawn_contract     p,
           credit_pawn       cp,
           account_attr_stat aas,
           kl_s031           k
     where cp.credit_document_id = c_contract_id
       and cd.id = cp.pawn_contract_id
       and cd.status <> 'CLOSED'
       and cd.status <> 'VACANT'
       and cp.pawn_contract_id = p.id
       and aas.id = p.pawn_account_id
       and aas.kl_s031_id = k.id;
       
    cursor count_s031(c_contract_id pls_integer) is --сколько залогов разных видов?
    select count(distinct s031.code)
      from credit_pawn       cp,
           compound_document cd,
           pawn_contract     p,
           account_attr_stat aas,
           kl_s031           s031
     where cp.credit_document_id = c_contract_id
       and cd.id = cp.pawn_contract_id
       and cd.status <> 'CLOSED'
       and cd.status <> 'VACANT'
       and cp.pawn_contract_id = p.id
       and p.pawn_account_id = aas.id
       and s031.id = aas.kl_s031_id;
         
    cursor pawn(c_s031_code string) is -- s030, s031, s032 (вычисляемые)
    select k31.id         s031_id,
           k31.kl_s030_id s030_id,
           k31.kl_s032_id s032_id,
           k31.code       as s031_code,
           k30.code       as s030_code,
           k32.code       as s032_code
      from kl_s031 k31, kl_s030 k30, kl_s032 k32
     where k31.code = c_s031_code
       and k31.d_close is null
       and k31.kl_s030_id = k30.id
       and k31.kl_s032_id = k32.id;
    pawn_rec pawn%rowtype;
    
  p_pawn_base_amount    account.amount%type := 0; --сумма залога
  p_cred_base_amount    account.amount%type := 0; --сумма кредита  
  
    cursor get_pawn_amount(c_contract_id pls_integer) is --сумма всех залогов жилого имущества по договору
    select nvl(sum(c_p.begin_base_amount), 0)
      from contract          c_c,
           contract          c_p,
           compound_document cd,
           credit_pawn       cp,
           pawn_contract     pc,
           account_attr_stat aas_p,
           kl_s031           s031
     where c_c.id = c_contract_id
       and cp.credit_document_id = c_c.id
       and cp.pawn_contract_id = c_p.id
       and cp.pawn_contract_id = cd.id
       and cd.status <> 'CLOSED'
       and cd.status <> 'VACANT'
       and c_c.customer_id = c_p.customer_id
       and c_p.id = pc.id
       and pc.pawn_account_id = aas_p.id
       and aas_p.kl_s031_id = s031.id
       and s031.code = '25';
  
    cursor get_cred_amount(c_contract_id pls_integer) is --сумма по кредитному договору с учетом линий
    select nvl(sum(c.begin_base_amount), 0)
      from contract c
     where c.parent_id = c_contract_id
       and c.id = c_contract_id
       and c.close_date is null;   
       
   m_count_s260 pls_integer;
   --находим кол-во счетов для простановки s260
   cursor count_s260(c_contract_id pls_integer) is 
    select count(*) kol
      from 
           contract_account  ca,
           account           a,
           balance_account   ba,
           kod_r020          r020,
           account_attr_stat aas    
      where 
           ca.contract_id = p_contract_id and
           a.id = ca.account_id and
           a.balance_id = ba.id and
           ba.id = r020.balance_account_id and
           r020.d_close is null and
           r020.stat_report_pole = 'F_D5' and
           a.id = aas.id(+) and
           aas.kl_s260_id is null; 
     -- having  count(*)>0;    
    --s080      
    cursor S080Cur(p_credit_stan_id pls_integer, -- S080 из CREDIT_BORG_STAN_S080
                   p_credit_borg_id pls_integer)
    is
      select k.id,
             k.code,
             k.name,
             k.d_close,
             k.kl_s081_id
        from credit_borg_stan_s080 c,
             kl_s080 k
       where c.kl_s080_id = k.id
         and c.credit_borg_id = p_credit_borg_id
         and c.credit_stan_id = p_credit_stan_id;
    S080Rec S080Cur%rowtype;
    -- Информация по кредиту Credit_Borg, Credit_Stan, номер, вычисление s080 и s081 по стране и p010
    cursor Cred_Info_Cur(p_contract_id contract.id%type)
    is
      select 
           ci.credit_stan_id,
           ci.credit_borg_id,
           doc.doc_no,
           decode(p010.code,4,decode(rez.country_id, null, '7', rez.country_group),3,'9') s080,
           decode(p010.code, 4, '9', 3, '8') s081    
        from contract ct,
             compound_document doc,
             customer cust,
             credit_info ci,
             kl_p010 p010,
             rezgroup rez
       where ct.id = p_contract_id
         and doc.id = ct.id
         and ci.id(+) = ct.id
         and ct.customer_id = cust.id
         and cust.kl_p010_id = p010.id
         and cust.country_id = rez.country_id (+);
    Cred_Info_Rec Cred_Info_Cur%rowtype;

    cursor S080Cur_for_bank(p_kl_s080_code pls_integer,  -- S080 на коррсчетах банков
                            p_kl_s081_code pls_integer)
    is
    select s080.id kl_s080_id, 
           s080.kl_s081_id   
      from kl_s080 s080, 
           kl_s081 s081
     where s080.d_close is null
       and s080.kl_s081_id = s081.id
       and s080.code = p_kl_s080_code
       and s081.code = p_kl_s081_code;
    Rec_bank S080Cur_for_bank%rowtype; 
 --r013
 cursor cur_r013(c_contract_id pls_integer) is 
    select ba.code as bal_acc_code, a.id account_id, a.account_number
      from 
           contract_account  ca,
           account           a,
           balance_account   ba,
           account_attr_stat aas    
      where 
           ca.contract_id = p_contract_id and
           a.id = ca.account_id and
           a.balance_id = ba.id and
           ba.code in ('2232','2233','2238','2010', '2016', '2020', '2026', '2030', '2036', '2062',
                       '2063','2065','2066','2071', '2072', '2073', '2074',
                       '2075','2076','2082','2083', '2085', '2086') and
           a.id = aas.id(+); 
   m_r013  cur_r013%rowtype;   
--r011
 cursor cur_r011(c_contract_id pls_integer) is 
 Select CA.Account_Id, BA.Code as bal_acc_code, a.account_number
                     From Contract_Account CA, Account A, Balance_Account BA
                    Where CA.Contract_Id = P_Contract_Id
                      And A.Id = CA.Account_Id
                      And A.Account_Class <> 'A'
                      And A.Balance_Id = BA.Id
                         --в случае добавления счетов сюда их необходимо добавить и в самую нижнюю выборку
                      And Trim(BA.Code) In
                          ('2028', '2029', '2068', '2069', '2078', '2079',
                           '2088', '2089', '2208', '2209', '2218', '2219',
                           '2238', '2239','1508','1509')
                      And CA.Is_Common = 'F';
    m_r011  cur_r011%rowtype;    
    L_R011_Code Varchar2(30);
    L_R011_Id  Pls_Integer;   
--s270
    L_S270_Code Varchar2(30);
    
    Cursor Get_S270_Id(L_Code Varchar2) Is
      Select Id
        From Kl_S270
       Where Code = L_Code
         And (D_Close Is Null Or D_Close > P_Contract.Get_Doc_Bank_Date)
         And (D_Open Is Null Or D_Open <= P_Contract.Get_Doc_Bank_Date);
    L_S270_Id   Pls_Integer;
 --для счетов остатка   
    Cursor cur_s270 (c_contract_id pls_integer) is
    Select CA.Account_Id, GAM.Sys_Name, A.Account_Number
                    From Contract_Account    CA,
                         Account             A,
                         Balance_Account     BA,
                         Contract_Acc_Macro  CAM,
                         Generator_Acc_Macro GAM
                   Where CA.Contract_Id = P_Contract_Id
                     And CA.Macro_Id = CAM.Id
                     And CAM.Macro_Id = GAM.Id
                     And A.Id = CA.Account_Id
                     And A.Account_Class <> 'A'
                     And A.Balance_Id = BA.Id
                     And Trim(BA.Code) In
                         ('1500', '1502', '1510', '1512', '1513', '1514',
                          '1520', '1521', '1522', '1523', '1524', '2010',
                          '2020', '2030', '2062', '2063', '2071', '2072',
                          '2073', '2074', '2082', '2083', '2102', '2103',
                          '2112', '2113', '2122', '2123', '2132', '2133',
                          '2202', '2203', '2211', '2220', '2232', '2233',
                          '2600', '2605', '2650', '2655', '2620', '2625',
                          '1517', '1527', '2027', '2037', '2067', '2077',
                          '2087', '2107', '2117', '2127', '2137', '2207',
                          '2217', '2227', '2237')
                     And CA.Is_Common = 'F';
    m_s270  cur_s270%rowtype;       
               
    Cursor Get_Acc_Stat(P_Acc_Id Pls_Integer) Is
      Select At.Kl_S270_Id
        From Account_Attr_Stat At
       Where At.Id = P_Acc_Id;
    Acc_Stat Get_Acc_Stat%RowType;
    
    R_Acc_No   Varchar2(30);
    R_Acc_Id   Pls_Integer;
    R_R        Number;
    E_R        Number;
    S_R        Number;
    Is_Overdue Boolean;     
                 
  begin
    p_s031_code := Null;
      
    open  is_line(p_contract_id);
    fetch is_line into is_line_rec;
  
    if is_line_rec.contract_mode in (1, 2) --режим обычный или родительский - анализируем залог по этому кред.договору?
    then
      f_contract_id := p_contract_id;
    elsif is_line_rec.contract_mode = 3 
    then                              --режим линия - залоги смотрим по родителю
      f_contract_id := is_line_rec.parent_id;
    end if;
    close is_line;
  
    open  get_has_pawn(f_contract_id);
    fetch get_has_pawn into p_is_pawn;
    close get_has_pawn;
    
    case p_is_pawn
    when 'T' then  -- один залог
      open  get_s031(f_contract_id); 
      fetch get_s031 into p_s031_code;
      close get_s031;
    when 'F' then  -- нет залога
       p_s031_code := '90';
    when 'M' then  -- несколько залогов
      open  count_s031(f_contract_id); 
      fetch count_s031 into p_count_S031;
      close count_s031;
         
      if p_count_S031 = 1 -- несколько договоров залога одного вида
      then
        open  get_s031(f_contract_id);
        fetch get_s031 into p_s031_code;
        close get_s031;
      else
        p_s031_code := '40'; -- несколько договоров залога разного вида
      end if;
    else null; 
    end case;
 
      open  pawn(p_s031_code);  
      fetch pawn into pawn_rec;
      close pawn;
      
      Cred_Info_Rec := null; 
      open  Cred_Info_Cur(p_contract_id);
      fetch Cred_Info_Cur into Cred_Info_Rec;
      close Cred_Info_Cur;
      
      m_kl_s030_id:=null;
      m_kl_s031_id:=null;
      m_kl_s031_id:=null;  
        
      m_kl_s030_id:=pawn_rec.s030_id;
      m_kl_s031_id:=pawn_rec.s031_id;
      m_kl_s032_id:=pawn_rec.s032_id;
      
      merge into account_attr_stat aas
       using  (select distinct(a.id) account_id,
                      m_kl_s030_id kl_s030_id,
                      m_kl_s031_id kl_s031_id,
                      m_kl_s032_id kl_s032_id
                 from contract_account    ca,
                      account             a,
                      balance_account     ba,
                      kod_r020            r020,
                      account_attr_stat   aas
                where ca.contract_id = p_contract_id
                  and a.id = ca.account_id
                  and a.balance_id = ba.id
                  and ba.id = r020.balance_account_id
                  and r020.d_close is null
/*                  and ((r020.stat_report_pole = 'F_D5' and ba.code!='2600')  
                     or(r020.stat_report_pole = 'F_D5' and ba.code='2600'and ca.is_rest='T'))
                  */
                  and ((r020.stat_report_pole in ('F_D5','F_11') and ba.code!='2600')  
                     or(r020.stat_report_pole in ('F_D5','F_11') and ba.code='2600'and ca.is_rest='T'))
                  and a.id = aas.id(+)
                  and (m_kl_s030_id is not null or m_kl_s031_id is not null or m_kl_s032_id is not null) and
                (aas.kl_s030_id is null or aas.kl_s030_id<>m_kl_s030_id or 
                 aas.kl_s031_id is null or aas.kl_s031_id<>m_kl_s031_id or
                 aas.kl_s032_id is null or aas.kl_s032_id<>m_kl_s032_id )) a
    on (aas.id = a.account_id)
    when matched then update set
      aas.kl_s030_id = a.kl_s030_id,
      aas.kl_s031_id = a.kl_s031_id,
      aas.kl_s032_id = a.kl_s032_id  
    when not matched then insert 
        (aas.id, aas.kl_s030_id, kl_s031_id, kl_s032_id) 
      values
        (a.account_id, a.kl_s030_id, a.kl_s031_id, a.kl_s032_id);
    if sql%rowcount>0 then    
      p_base_action.notify_action_desc_fmt('На счетах договора (№%s) проставлены S030=%s, S031=%s, S032=%s',
                                           Cred_Info_Rec.Doc_No,
                                           pawn_rec.s030_code, pawn_rec.s031_code, pawn_rec.s032_code);
    end if;    
--проставить r013 на счетах 2232/2233, 2238 
  open cur_r013(p_contract_id);
  fetch cur_r013 into m_r013;
  close cur_r013;
    if m_r013.bal_acc_code is not null then
    
    for m_r013 in cur_r013(p_contract_id) loop
  --  p_exception.raise_common_except(m_r013.account_id);
     m_kl_r013_id:=get_r013_id_by_acc_id(p_contract_id,m_r013.account_id);
 
      merge into account_attr_stat aas
       using  (select ca.account_id,  -- выбрать сч. ссудной,просроч.,сомнит.задолженности,процентов и комиссий, дисконта
                      m_kl_r013_id kl_r013_id
                 from contract_account    ca,
                      account             a,
                      balance_account     ba,
                      account_attr_stat   aas
                where ca.contract_id = p_contract_id
                  and a.id = ca.account_id
                  and a.balance_id = ba.id
                  and ba.code=m_r013.bal_acc_code
                  and a.id = aas.id(+)
                  and m_kl_r013_id is not null
                  and(aas.kl_r013_id is null or aas.kl_r013_id<>m_kl_r013_id)) a   
        on (aas.id = a.account_id)
      when matched then update set
        aas.kl_r013_id = a.kl_r013_id  
      when not matched then insert 
          (aas.id, aas.kl_r013_id) 
        values
          (a.account_id, a.kl_r013_id);
                                        
      if sql%rowcount>0 then    
        p_base_action.notify_action_desc_fmt('На счете %s договора (№%s) проставлен R013=%s',
                                             m_r013.account_number,
                                             Cred_Info_Rec.Doc_No,
                                             fc_gb_func_and_proc.get_dict_code_by_id('KL_R013',m_kl_r013_id));
      end if; 
 
      end loop;
            end if; 
  
--проставить S260 по выбранным счетам договора
  
  open count_s260(p_contract_id);
  fetch count_s260 into m_count_s260;
  close count_s260;
  
  if m_count_s260>0 then
                 
     m_kl_s260_id := get_s260_id_by_con_id(p_contract_id => p_contract_id);
     
     merge into account_attr_stat aas
         using (select 
                  ca.account_id,
                  m_kl_s260_id kl_s260_id
                from 
                  contract_account    ca,
                  account             a,
                  balance_account     ba,
                  kod_r020            r020,
                  account_attr_stat aas    
                where 
                  ca.contract_id = p_contract_id and
                  a.id = ca.account_id and
                  a.balance_id = ba.id and
                  ba.id = r020.balance_account_id and
                  r020.d_close is null and
                  r020.stat_report_pole = 'F_D5' and
                  a.id = aas.id(+) and
                  m_kl_s260_id is not null and
                  (aas.kl_s260_id is null or aas.kl_s260_id<>m_kl_s260_id)) a                                                        
        on (aas.id = a.account_id)
      when matched then update set
        aas.kl_s260_id = a.kl_s260_id  
      when not matched then insert 
          (aas.id, aas.kl_s260_id) 
        values
          (a.account_id, a.kl_s260_id);
                                        
      if sql%rowcount>0 then    
        p_base_action.notify_action_desc_fmt('На счетах договора (№%s) проставлен статпараметр S260=%s',
                                             Cred_Info_Rec.Doc_No,
                                             fc_gb_func_and_proc.get_dict_code_by_id('KL_S260',m_kl_s260_id));
      end if;                                     
   end if;  
    
 --s080, s081
     m_kl_s080_id:=null;
     m_kl_s081_id:=null; 
              
     S080Rec := null;      -- Значение S080 из настройки CREDIT_BORG_STAN_S080   
     open  S080Cur(Cred_Info_Rec.Credit_Stan_Id,  Cred_Info_Rec.Credit_Borg_Id);
     fetch S080Cur into S080Rec;
     close S080Cur;
   --p_exception.raise_common_except(Cred_Info_Rec.Credit_Borg_Id||' '||Cred_Info_Rec.Credit_Stan_Id);       
     m_kl_s080_id:=S080Rec.Id;
     m_kl_s081_id:=S080Rec.Kl_S081_Id;
--   p_exception.raise_common_except(Cred_Info_Rec.Credit_Borg_Id||' '||Cred_Info_Rec.Credit_Stan_Id||' ' );  
   merge into account_attr_stat aas
       using  (select distinct(a.id) account_id,
                      m_kl_s080_id kl_s080_id,
                      m_kl_s081_id kl_s081_id
                 from contract_account    ca,
                      account             a,
                      balance_account     ba,
                      kod_r020            r020,
                      account_attr_stat   aas
                where ca.contract_id = p_contract_id
                  and a.id = ca.account_id
                  and a.balance_id = ba.id
                  and ba.id = r020.balance_account_id
                  and r020.d_close is null
                  and ((r020.stat_report_pole in ('F_D5','F_11') and ba.code!='2600')  
                     or(r020.stat_report_pole in ('F_D5','F_11') and ba.code='2600'and ca.is_rest='T'))
                  and a.id = aas.id(+)
                  and (m_kl_s080_id is not null or m_kl_s081_id is not null) and
                (aas.kl_s080_id is null or aas.kl_s080_id<>m_kl_s080_id or 
                 aas.kl_s081_id is null or aas.kl_s081_id<>m_kl_s081_id)
                 group by a.id) a
    on (aas.id = a.account_id)
    when matched then update set
      aas.kl_s080_id = a.kl_s080_id,
      aas.kl_s081_id = a.kl_s081_id 
    when not matched then insert 
        (aas.id, aas.kl_s080_id, kl_s081_id) 
      values
        (a.account_id, a.kl_s080_id, a.kl_s081_id);
                                
      if sql%rowcount>0 then    
              p_base_action.notify_action_desc_fmt('На счетах договора (№%s) проставлены статпараметры S080=%s, S081=%s',
                                           Cred_Info_Rec.Doc_No,
                                           fc_gb_func_and_proc.get_dict_code_by_id('KL_S080',m_kl_s080_id),
                                           fc_gb_func_and_proc.get_dict_code_by_id('KL_S081',m_kl_s081_id)); 
      end if;   
         
-- на корсчетах банков
     m_kl_s080_id:=null;
     m_kl_s081_id:=null; 
     
     Rec_bank := null;
     open  S080Cur_for_bank(Cred_Info_Rec.S080, Cred_Info_Rec.S081);
     fetch S080Cur_for_bank into Rec_bank;
     close S080Cur_for_bank;
     
     m_kl_s080_id:=Rec_bank.Kl_S080_Id;
     m_kl_s081_id:=Rec_bank.Kl_S081_Id; 
             
   merge into account_attr_stat aas
       using ( -- проставить по сч. ссудной,просроч.,сомнит.задолженности,обязательств и дисконта
              select c_a.account_id,
                     m_kl_s080_id kl_s080_id,
                     m_kl_s081_id kl_s081_id
                from contract_account c_a,
                     credit_document   doc,
                     account a,
                     balance_account ba,
                     account_attr_stat aas
               where c_a.contract_id = p_contract_id
                 and doc.id = c_a.contract_id
                 and doc.account_rest_id in
                 (select id from account t where substr(t.account_number, 1, 4) = '1500')
                 and a.id = c_a.account_id
                 and a.balance_id = ba.id
                 and (ba.code='1500'or ba.code='1508' or ba.code='1509')
                 and a.id = aas.id(+)
                 and (m_kl_s080_id is not null or m_kl_s081_id is not null) and
                (m_kl_s080_id is null or aas.kl_s080_id<>m_kl_s080_id or
                 m_kl_s081_id is null or aas.kl_s081_id<>m_kl_s081_id)
              )a                                                        
      on (aas.id = a.account_id)
      when matched then update set
        aas.kl_s080_id = Rec_bank.Kl_S080_Id,  
        aas.kl_s081_id = Rec_bank.Kl_S081_Id
      when not matched then insert 
          (aas.id, aas.kl_s080_id, aas.kl_s081_id) 
        values
          (a.account_id, Rec_bank.Kl_S080_Id, Rec_bank.Kl_S081_Id);
                          
      if sql%rowcount>0 then    
              p_base_action.notify_action_desc_fmt('На счетах договора (№%s) проставлены статпараметры S080=%s, S081=%s',
                                           Cred_Info_Rec.Doc_No,
                                           fc_gb_func_and_proc.get_dict_code_by_id('KL_S080',m_kl_s080_id),
                                           fc_gb_func_and_proc.get_dict_code_by_id('KL_S081',m_kl_s081_id));
      end if;        
 --s270 lds 09.12.2009
    R_Acc_Id := To_Number(D_Credit.Get_Param_Hist_Value(p_contract.get_doc_bank_date,
                                                        p_Contract_Id,
                                                        'REST_ACC'));
    If R_Acc_Id Is Null Then
      R_Acc_Id := P_Contract.Get_Acc_Id_By_Macro(P_Contract_Id,
                                                 'CREDIT_REST');
      If R_Acc_Id Is Null Then
        P_Base_Action.Notify_Action_Desc('Для договора с ИД ' ||
                                        To_Char(P_Contract_Id) ||
                                        ' не найден счет остатка!');
       -- Return;
      End If;
    End If;
    R_Acc_No := P_Account.Get_Account_No(R_Acc_Id);
    If Substr(R_Acc_No, 1, 2) In ('15', '20', '21', '22', '26','90','91') Then
      --полагаем, что договор не просрочен
      Is_Overdue := False;
      --получим остатки на счетах
      R_R := Nvl(P_Rest_Engine.Get_Account_Rest(Nvl(P_Contract.Get_Acc_Id_By_Macro(P_Contract_Id,
                                                                                   'CREDIT_REST'),
                                                    0),
                                                p_contract.get_doc_bank_date),
                 0);
      E_R := Nvl(P_Rest_Engine.Get_Account_Rest(Nvl(P_Contract.Get_Acc_Id_By_Macro(P_Contract_Id,
                                                                                   'CREDIT_EXPIRE'),
                                                    0),
                                                p_contract.get_doc_bank_date),
                 0);
      S_R := Nvl(P_Rest_Engine.Get_Account_Rest(Nvl(P_Contract.Get_Acc_Id_By_Macro(P_Contract_Id,
                                                                                   'CREDIT_REST_SUMN'),
                                                    0),
                                                p_contract.get_doc_bank_date),
                 0);
      --вычислим значения от остатков на счетах
      If ((R_R = 0) And (E_R = 0) And (S_R = 0)) Or
         ((R_R <> 0) And (E_R = 0) And (S_R = 0)) Then
        L_S270_Code := '01';
      Else
        If ((R_R <> 0) And (E_R <> 0) And (S_R = 0)) Or
           ((R_R <> 0) And (E_R <> 0) And (S_R <> 0)) Or
           ((R_R = 0) And (E_R <> 0) And (S_R = 0)) Or
           ((R_R = 0) And (E_R <> 0) And (S_R <> 0)) Or
           ((R_R <> 0) And (E_R = 0) And (S_R <> 0)) Then
          L_S270_Code := '07';
          If R_R = 0 Then
            --договор просрочен
            Is_Overdue := True;
          End If;
        Else
          If ((R_R = 0) And (E_R = 0) And (S_R <> 0)) Then
            L_S270_Code := '08';
            --договор просрочен
            Is_Overdue := True;
          Else
            If Substr(R_Acc_No, 4, 1) = '7' Then
              L_S270_Code := '08';
              --договор просрочен
              Is_Overdue := True;
            Else
              L_S270_Code := '01';
            End If;
          End If;
        End If;
      End If;
      Open Get_S270_Id(L_S270_Code);
      Fetch Get_S270_Id
        Into L_S270_Id;
      Close Get_S270_Id;
      --проставим значение s270 на счетах доходов
      merge into account_attr_stat aas
       using  (Select CA.Account_Id, L_S270_Id kl_s270_id
                    From Contract_Account CA, Account A, Balance_Account BA, account_attr_stat aas
                   Where CA.Contract_Id = P_Contract_Id
                     And A.Id = CA.Account_Id
                     And A.Account_Class <> 'A'
                     And A.Balance_Id = BA.Id
                        --в случае добавления счетов сюда их необходимо добавить и в самую нижнюю выборку
                     And Trim(BA.Code) In
                         ('2028', '2029', '2038', '2039', '2068', '2069',
                          '2078', '2079', '2088', '2089', '2108', '2109',
                          '2118', '2119', '2128', '2129', '2138', '2139',
                          '2208', '2209', '2218', '2219', '2228', '2229',
                          '2238', '2239', '1518', '1519', '1528', '1529',
                          '2607', '2627', '2657')
                     And CA.Is_Common = 'F'
                     and a.id = aas.id(+)
                     and L_S270_Id is not null
                     and(aas.kl_s270_id is null or aas.kl_s270_id<>L_S270_Id)) a   
        on (aas.id = a.account_id)
      when matched then update set
        aas.kl_s270_id = a.kl_s270_id  
      when not matched then insert 
          (aas.id, aas.kl_s270_id) 
        values
          (a.account_id, a.kl_s270_id);
                                        
      if sql%rowcount>0 then    
        p_base_action.notify_action_desc_fmt('На счете %s договора (№%s) проставлен S270=%s',
                                             R_Acc_No,
                                             Cred_Info_Rec.Doc_No,
                                             fc_gb_func_and_proc.get_dict_code_by_id('KL_S270',L_S270_Id));
      end if; 
      
      --End Loop;
 
 --проставим значение r011 
  open cur_r011(p_contract_id);
  fetch cur_r011 into m_r011;
  close cur_r011;
     if m_r011.bal_acc_code is not null then
      for m_r011 in cur_r011(p_contract_id) loop
       l_r011_id:=get_r011_id_by_acc_id(p_contract_id,m_r011.account_id, is_overdue);      
      
       merge into account_attr_stat aas
        using  (select ca.account_id,  -- выбрать сч. ссудной,просроч.,сомнит.задолженности,процентов и комиссий, дисконта
                      l_r011_id kl_r011_id
                 from contract_account    ca,
                      account             a,
                      balance_account     ba,
                      account_attr_stat   aas
                where ca.contract_id = p_contract_id
                  and a.id = ca.account_id
                  and a.balance_id = ba.id
                  and ba.code=m_r011.bal_acc_code
                  and a.id = aas.id(+)
                  and l_r011_id is not null
                  and(aas.kl_r011_id is null or aas.kl_r011_id<>l_r011_id)) a   
        on (aas.id = a.account_id)
       when matched then update set
        aas.kl_r011_id = a.kl_r011_id  
       when not matched then insert 
          (aas.id, aas.kl_r011_id) 
        values
          (a.account_id, a.kl_r011_id);
                                          
        if sql%rowcount>0 then    
          p_base_action.notify_action_desc_fmt('На счете %s договора (№%s) проставлен R011=%s',
                                               m_r011.account_number,
                                               Cred_Info_Rec.Doc_No,
                                               fc_gb_func_and_proc.get_dict_code_by_id('KL_R011',l_r011_id));
        end if; 
       end loop;
     end if; 
     
     --простановка S270 на счетах остатка
  open cur_s270(p_contract_id);
  fetch cur_s270 into m_s270;
  close cur_s270; 
  L_S270_Code:=Null;
  L_S270_Id:=Null;
  if m_s270.Account_Id is not null then
        Acc_Stat := Null;
        Open Get_Acc_Stat(m_s270.Account_Id);
        Fetch Get_Acc_Stat
          Into Acc_Stat;
        Close Get_Acc_Stat;
  end if;      
 
    for m_s270 in cur_s270(p_contract_id) loop      
        If (Acc_Stat.Kl_S270_Id Is Null) Then
          --получим код S270
          If Substr(m_s270.Account_Number, 4, 1) = '7' Then
            L_S270_Code := '07';
            If m_s270.Sys_Name = 'CREDIT_REST_SUMN' Then
              L_S270_Code := '08';
            End If;
          Else
            L_S270_Code := '01';
          End If;
          Open Get_S270_Id(L_S270_Code);
          Fetch Get_S270_Id
            Into L_S270_Id;
          Close Get_S270_Id;
      --  end if; 
       merge into account_attr_stat aas
        using  (select ca.account_id,  -- выбрать сч. ссудной,просроч.,сомнит.задолженности,процентов и комиссий, дисконта
                      l_s270_id kl_s270_id
                 from contract_account    ca,
                      account             a,
                      balance_account     ba,
                      account_attr_stat   aas
                where ca.contract_id = p_contract_id
                  and a.id = ca.account_id
                  and a.balance_id = ba.id
                  and a.id=m_s270.account_id
                  and a.id = aas.id(+)
                  and l_s270_id is not null
                  and(aas.kl_s270_id is null or aas.kl_s270_id<>l_s270_id)) a   
        on (aas.id = a.account_id)
       when matched then update set
        aas.kl_s270_id = a.kl_s270_id  
       when not matched then insert 
          (aas.id, aas.kl_s270_id) 
        values
          (a.account_id, a.kl_s270_id);
                                          
        if sql%rowcount>0 then    
          p_base_action.notify_action_desc_fmt('На счете %s договора (№%s) проставлен S270=%s',
                                               m_s270.account_number,
                                               Cred_Info_Rec.Doc_No,
                                               fc_gb_func_and_proc.get_dict_code_by_id('KL_S270',l_s270_id));
        end if; 
        end if;
       end loop;
--     end if; 

  end if;
 --end s270 
         
    if p_s031_code is Null and m_kl_r013_id is null and m_kl_s260_id is null and
       m_kl_s080_id is null and l_r011_id is null and L_S270_Code is null
    then
      Return(False);
    else
      Return(True);
    end if;
  end;   
  
  --Процедура открытия кредитного договора
  Procedure On_Credit_Doc_Open(P_Template_Id       In Generator_Template.Id%Type,
                               P_Additional_Params In Varchar2) Is
    Err           Varchar2(2000);
    Res           Boolean;
    P_Expire_Pcnt Number;
    m_kl_s260_id kl_s260.id%type;    
  Begin
    Err := '!!!';
    If Not (Is_Fin_Status_Set(P_Base_Action.Get_Current_Comp_Doc_Id)) Then
      Err := Err || Chr(13) || 'Не заполнено Фин.положение заемщика!!!';
    End If;
    If Not (Is_Credit_Debt_Set(P_Base_Action.Get_Current_Comp_Doc_Id)) Then
      Err := Err || Chr(13) || 'Не заполнено Обслуживание долга!!!';
    End If;
    If Not (Is_Credit_Output_Set(P_Base_Action.Get_Current_Comp_Doc_Id)) Then
      Err := Err || Chr(13) || 'Не заполнено Разрешение на выдачу!!!';
    End If;
    If Not (Is_Schedule_Calculated(P_Base_Action.Get_Current_Comp_Doc_Id)) Then
      Err := Err || Chr(13) ||
             'Не рассчитан график погашений по договору!!!';
    End If;
    If Not (Is_Pawn_Present(P_Base_Action.Get_Current_Comp_Doc_Id)) Then
      P_Base_Action.Notify_Action_Desc('У кредита нет связанного договора залога/поручительства!!!');
    End If;
    If Not (Set_Stat_Param(P_Base_Action.Get_Current_Comp_Doc_Id)) Then
      Err := Err || Chr(13) ||
             'На счетах кредитного договора не удалось проставить статпараметры!!!';
    End If;
    If Err <> '!!!' Then
      P_Exception.Raise_Common_Except(Err);
    End If;
    Res := Is_Contract_Accounts_Unique(P_Base_Action.Get_Current_Comp_Doc_Id);
    --автооткрытие счетов
    /*   If P_Params_Translator.Get_Dat_Param(P_Additional_Params,'OPEN_DATE',False) Is Not Null Then
          P_Base_Action.Exec_Open_Account(P_Date => P_Params_Translator.Get_Dat_Param(P_Additional_Params,'OPEN_DATE'),
                                          P_Contract_Id => P_Base_Action.Get_Current_Comp_Doc_Id,
                                          P_Operation_Code => 'CRED_OPEN_ACCOUNT',
                                          P_Group_Account => P_Params_Translator.Get_Int_Param(P_Additional_Params,'GROUP_OPEN_ACCOUNTS'));
       End If;
    */
    -- простановка доп. параметров на необходимых счетах (см тз)
    Set_Product_Type(P_Base_Action.Get_Current_Comp_Doc_Id);
    --вызов стандартной функции
    D_Credit_Generator.On_Open_Doc(P_Template_Id, P_Additional_Params);
    --если есть плавающая ставка - занесем ее в параметры жоговора
    Save_Interest_Range_To_Params(P_Base_Action.Get_Current_Comp_Doc_Id);
    --простановка статпараметров эффективной ставки
    FC_GB_Calc_Param.CalcF090(P_Template_Id, P_Additional_Params);
    --ams 27/01/2009
    --простановка % ставки при просрочке кредита
    --если указана в параметре операции, то устанавливается она, если там пусто,
    --то остается та, которую проставляет стандартное открытие
    P_Expire_Pcnt := P_Params_Translator.Get_Num_Param(P_Additional_Params,
                                                       'INT_PART_EXPIRE',
                                                       False);
    If (P_Expire_Pcnt Is Not Null) And (P_Expire_Pcnt <> 0) Then
      D_Credit.Modify_Param(P_Base_Action.Get_Current_Comp_Doc_Id,
                            'INT_PART_EXPIRE',
                            Trim(To_Char(P_Expire_Pcnt, 'FM9990.000000')));
    End If;
    --end ams
    -- Kravchenko A.V. (12.03.09 17:58:13)
    -- Простановка S260 на счетах договора
    for c_list_acc in (select
                         ca.account_id
                       from
                         contract_account ca,
                         contract_acc_macro cam,
                         generator_acc_macro gam
                        where
                         ca.contract_id = P_Base_Action.Get_Current_Comp_Doc_Id and
                         ca.macro_id = cam.id and
                         cam.macro_id= gam.id and
                         gam.sys_name not in ('CUSTOMER_ACCOUNT',
                                              'OVERDRAFT_LIMIT',
                                              'CREDIT_LIMIT',
                                              'CREDIT_ZALOG',
                                              'PAWN',
                                              'PAWN2'))
    loop
--ams 2009-07-02
--проставим значения статпараметров s180, s181, s183
      p_auto_open_account.update_cred_account_s180(null,c_list_acc.account_id,P_Base_Action.Get_Current_Comp_Doc_Id,null);
--проставим значениея статпараметра r011
      p_auto_open_account.update_cred_account_r011(null,c_list_acc.account_id,P_Base_Action.Get_Current_Comp_Doc_Id,null);
--end ams
      m_kl_s260_id := null;
      m_kl_s260_id := fc_cred_procedures.get_s260_id_by_acc_id( c_list_acc.account_id,P_Base_Action.Get_Current_Comp_Doc_Id);
      
      update account_attr_stat s set
        s.kl_s260_id = m_kl_s260_id
      where
        s.id = c_list_acc.account_id;   
    
    end loop;                                  
    -- end Kravchenko A.V.
    
  End;

--Процедура простановки статпараметров s032,s080,s260,r013 на кред. счетах (для операции)
  procedure On_Modify_Stat_Param(p_template_id       in generator_template.id%type,
                                 p_additional_params in varchar2) is
    p_contract_id pls_integer;
    p_result      boolean;
  begin
    p_contract_id := p_base_action.get_current_comp_doc_id;
    p_result      := Fc_Cred_Procedures.Set_Stat_Param(p_contract_id => p_contract_id);
  end On_Modify_Stat_Param;

  --Получение суммы единоразовой комиссии (сумма операции)
  Function Get_Mono_Fee_Amount(P_Operation_Id         In Operation.Id%Type,
                               P_Compound_Document_Id In Compound_Document.Id%Type)
    Return Number Is
    Res Number(38, 2);
    Cursor Get_Contract_Info(P_Contract_Id Pls_Integer, P_Param Varchar2) Is
      Select CD.Is_Commiss,
             CF.Amount,
             CFT.Type_Value,
             C.Doc_No,
             CC.Begin_Amount,
             CC.Currency_Id
        From Credit_Document   CD,
             Credit_Fine       CF,
             Credit_Fine_Type  CFT,
             Compound_Document C,
             Contract          CC
       Where CD.Id = P_Contract_Id
         And C.Id = CD.Id
         And CC.Id = CD.Id
         And CF.Credit_Id(+) = CD.Id
         And CFT.Id = CF.Type_Id
         And CFT.Code Like P_Param || '%';
    P_Con_Info Get_Contract_Info%RowType;
    Cursor Get_Oper_Params(P_Op_Id Pls_Integer) Is
      Select GT.Params_Info
        From Generator_Template GT
       Where GT.Operation_Id = P_Op_Id;
    P_Buf        Varchar2(16000);
    P_Param_Code Varchar2(32);
  Begin
    P_Buf := Null;
    Open Get_Oper_Params(P_Operation_Id);
    Fetch Get_Oper_Params
      Into P_Buf;
    Close Get_Oper_Params;
    If P_Buf Is Null Then
      P_Param_Code := 'MONO_COMMISS_OPEN_DOC'; --значение по умолчанию
    Else
      P_Buf        := Upper(P_Buf);
      P_Param_Code := Substr(P_Buf,
                             Instr(P_Buf, 'DEFAULTVALUE') + 15,
                             Instr(P_Buf, 'DEFAULTVALUEEND') -
                             Instr(P_Buf, 'DEFAULTVALUE') - 31);
      P_Param_Code := Nvl(P_Param_Code, 'MONO_COMMISS_OPEN_DOC'); --значение по умолчанию
    End If;
    Open Get_Contract_Info(P_Compound_Document_Id, P_Param_Code);
    Fetch Get_Contract_Info
      Into P_Con_Info;
    If Get_Contract_Info%RowCount = 0 Then
      Close Get_Contract_Info;
      P_Exception.Raise_Common_Except('У контракта ' || P_Con_Info.Doc_No ||
                                      ' не указана Единоразовая комиссия ' ||
                                      P_Param_Code || '!!!');
    End If;
    If Get_Contract_Info%RowCount > 1 Then
      Close Get_Contract_Info;
      P_Exception.Raise_Common_Except('У контракта ' || P_Con_Info.Doc_No ||
                                      ' указано БОЛЕЕ одной единоразовой комиссии!!!');
    End If;
    Close Get_Contract_Info;
    If (P_Con_Info.Is_Commiss = 'F') Or (P_Con_Info.Is_Commiss Is Null) Then
      P_Exception.Raise_Common_Except('По контракту ' || P_Con_Info.Doc_No ||
                                      ' комиссия не начисляется!');
    End If;
    If (P_Con_Info.Type_Value Is Null) Or (P_Con_Info.Amount Is Null) Then
      P_Exception.Raise_Common_Except('По контракту ' || P_Con_Info.Doc_No ||
                                      ' не задана величина и тип комиссии ' ||
                                      P_Param_Code || '!');
    End If;
    Res := 0;
    If P_Con_Info.Type_Value = 'A' Then
      --если абсолютная величина
      Res := P_Con_Info.Amount;
    Else
      --если процент от суммы
      If P_Con_Info.Type_Value = 'P' Then
        If P_Con_Info.Currency_Id =
           P_Registry.Get_Integer_Value('\COMMON', 'CURRENCY_ID', 3386) Then
          --если в гривне
          Res := P_Con_Info.Begin_Amount * 0.01 * P_Con_Info.Amount;
        Else
          --если в валюте
          Res := P_Con_Info.Begin_Amount * 0.01 * P_Con_Info.Amount *
                 P_Currency.Get_Kurs(P_Con_Info.Currency_Id,
                                     P_Contract.Get_Doc_Bank_Date);
        End If;
      Else
        P_Exception.Raise_Common_Except('Не верный тип (абсолютная величина или % от суммы) комиссии!');
      End If;
    End If;
    Return(Round(Res, 2));
  End;
  --получение остатков на счетах комиссии (всех) для суммы операции
  Function Oper$Get_Mono_Fee_Acc_Amount(P_Operation_Id         In Operation.Id%Type,
                                        P_Compound_Document_Id In Compound_Document.Id%Type)
    Return Number Is
    Cursor Get_Amount(P_Con_Id Pls_Integer, P_Date Date) Is
      Select Sum(Abs(P_Rest_Engine.Get_Account_Rest(CA.Account_Id, P_Date))) Amount
        From Contract_Account    CA,
             Contract_Acc_Macro  CAM,
             Generator_Acc_Macro GAM
       Where CA.Contract_Id = P_Con_Id
         And CAM.Id = CA.Macro_Id
         And GAM.Id = CAM.Macro_Id
         And GAM.Sys_Name In
             ('CREDIT_MONO_FEE_3570', 'CREDIT_MONO_FEE_3579_1',
              'CREDIT_MONO_FEE_3579_2', 'CREDIT_MONO_FEE_3589');
    Res Number(38, 2);
  Begin
    Res := Null;
    Open Get_Amount(P_Compound_Document_Id, P_Contract.Get_Doc_Bank_Date);
    Fetch Get_Amount
      Into Res;
    Close Get_Amount;
    Return(Nvl(Res, 0));
  End;
  --получение остатков на счетах (на шаге генератора по счету кредит) в операции погашения единоразовой комиссии
  Function Gen$Step_Mono_Fee_Acc_Amount(P_Currency_Id In Currency.Id%Type,
                                        P_Amount      In Action.Amount%Type,
                                        P_Step_Id     In Gen_Template_Step.Id%Type,
                                        P_Action_Id   In Action.Id%Type)
    Return Number Is
    Res Number(38, 2);
  Begin
    Res := FC_GB_Func_And_Proc.Get_Step_Credit_Acc_Rest(P_Currency_Id,
                                                        P_Amount,
                                                        P_Step_Id,
                                                        P_Action_Id);
    If (Res > P_Amount) And (P_Amount > 0) Then
      --на случай, если сумма операции введена руками и меньше??? расчетной
      Res := P_Amount;
    End If;
    Return(Res);
  End;
  --Прцедура простановки признака закрытия счета
  Procedure Set_Close_Acc_Mark(P_Template_Id       In Generator_Template.Id%Type,
                               P_Additional_Params In Varchar2) Is
  Begin
    Update Account_No A
       Set A.Description = A.Description || 'CLOSE_ACC=T'
     Where A.Account_Id In
           (Select CA.Account_Id
              From Contract_Account    CA,
                   Contract_Acc_Macro  CAM,
                   Generator_Acc_Macro GAM
             Where CA.Contract_Id = P_Base_Action.Get_Current_Comp_Doc_Id
               And CAM.Id = CA.Macro_Id
               And GAM.Id = CAM.Macro_Id
               And GAM.Sys_Name In
                   ('CREDIT_MONO_FEE_3570', 'CREDIT_MONO_FEE_3579_1',
                    'CREDIT_MONO_FEE_3579_2', 'CREDIT_MONO_FEE_3589'));
  End;
  --Регламент по закрытию счетов комиссий единоразовых
  --Вешать на ОТКРЫТИЕ!!!! дня
  Procedure RO_Close_Mono_Fee_Accounts(P_Date   Date,
                                       P_Posted Job_End_Day.Is_Posted%Type) Is
    Close_It   Comm_Bool_Array;
    Acc_Id     Comm_Integer_Array;
    i          Pls_Integer;
    k          Pls_Integer;
    Need_Close Boolean;
  Begin
    --перебор договоров
    For C In (Select Con.Id
                From Compound_Document Con, Credit_Document CD
               Where Con.Status <> 'CLOSED'
                 And Con.Id = CD.Id) Loop
      --обнуление переменных
      For k in 1 .. 4 Loop
        Close_It(k) := False;
        Acc_Id(k) := Null;
      End Loop;
      i := 1;
      --перебор счетов
      For CA In (Select AN.Description, A.Amount, A.Id
                   From Contract_Account    ConA,
                        Contract_Acc_Macro  CAM,
                        Generator_Acc_Macro GAM,
                        Account             A,
                        Account_No          AN
                  Where ConA.Contract_Id = C.Id
                    And CAM.Id = ConA.Macro_Id
                    And GAM.Id = CAM.Macro_Id
                    And GAM.Sys_Name In
                        ('CREDIT_MONO_FEE_3570', 'CREDIT_MONO_FEE_3579_1',
                         'CREDIT_MONO_FEE_3579_2', 'CREDIT_MONO_FEE_3589')
                    And A.Id = ConA.Account_Id
                    And AN.Account_Id = ConA.Account_Id) Loop
        If (CA.Amount = 0) And (Instr(CA.Description, 'CLOSE_ACC=T') > 0) Then
          --если остаток на счете=0 и счет помечен на закрытие
          Close_It(i) := True;
        End If;
        Acc_Id(i) := CA.Id;
        i := i + 1;
      End Loop;
      If i <= 4 Then
        For k in i .. 4 Loop
          Close_It(k) := True;
        End Loop;
      End If;
      Need_Close := True;
      For k In 1 .. 4 Loop
        Need_Close := Need_Close And Close_It(k);
      End Loop;
      --закрываем счета только тогда, когда все счета можно закрывать
      If Need_Close Then
        For k In 1 .. 4 Loop
          Begin
            If Acc_Id(k) Is Not Null Then
              P_Account.Close_Account(Acc_Id(k));
            End If;
          Exception
            When Others Then
              Null;
          End;
        End Loop;
      End If;
    End Loop;
  End;

  --регламент по просрочке единоразовой комиссии
  Procedure RO_Mono_Fee_Expire(P_Date   Date,
                               P_Posted Job_End_Day.Is_Posted%Type) Is
    Cursor Check_Oper_Valid(P_Oper_Id Pls_Integer, P_Type_Id Pls_Integer) Is
      Select Count(VCO.Id) Co
        From Valid_Contract_Operation VCO
       Where VCO.Operation_Id = P_Oper_Id
         And VCO.Type_Id = P_Type_Id;
    P_Op_Is_Valid       Pls_Integer;
    M_Old_Doc_Bank_Date Date;
    Op_Co               Pls_Integer;
    id_macro_array      p_utils.idarraytype;
    id_account_array    p_utils.idarraytype;
    p_rowid             rowid;
    p_action_id         pls_integer;
    p_amount            contract.begin_amount%type;
    p_gen_type          varchar2(255);
    p_operation_id      pls_integer;
    P_OPERATION_NO      ACTION.OPERATION_NO%TYPE;
    P_ACTION_AMOUNT     ACTION.AMOUNT%TYPE;
    p_additional_params varchar2(7000);
    P_SR_ROWID          rowid;
    p_template_id       pls_integer;
  Begin
    --сохраняем установленную дату документов (до начала процедуры)
    M_Old_Doc_Bank_Date := P_Contract.Get_Doc_Bank_Date;
    --устанавливаем новую дату (для процедуры)
    P_Contract.Set_Doc_Bank_Date(P_Date);
    Op_Co          := 1;
    P_Operation_Id := P_Get_Params.Get_Operation_Id('FC_CRED_MONO_FEE_EXPIRE');
    --пока есть записи в курсоре--------------------------------------------------------------------------
    For M_Contract_Info In (Select CD.Id Con_Id,
                                   Con.Currency_Id Cur_Id,
                                   Com.Doc_No Doc_No,
                                   Con.Type_Id
                              From Contract           Con,
                                   Credit_Document    CD,
                                   Compound_Document  Com,
                                   Contract_Type      CT,
                                   Bank_Product       BP,
                                   Contract_Type_Prop CTP
                             Where Con.Id = CD.Id
                               And Com.Id = CD.Id
                               And Com.Status <> 'CLOSED' --договор не закрыт
                               And CT.Id = Con.Type_Id
                               And CT.Is_Open = 'T' --тип открыт
                               And CTP.Id = CT.Contract_Type_Prop_Id
                               And CTP.Code = 'CT' -- берем только нижний уровень
                               And BP.Id = CT.Bank_Product_Id
                               And (BP.Code Like '00%' Or BP.Code Like '10%' Or
                                   BP.Code Like '11%')) Loop
      P_Action_Id    := Null;
      P_Rowid        := Null;
      P_Template_Id  := Null;
      P_Operation_No := To_Char(Op_Co, 'FM999999999990');
    
      Open Check_Oper_Valid(P_Operation_Id, M_Contract_Info.Type_Id);
      Fetch Check_Oper_Valid
        Into P_Op_Is_Valid;
      Close Check_Oper_Valid;
      --если операция определена на типе договора, то выполняем ее
      If P_Op_Is_Valid > 0 Then
        Begin
          Savepoint Tran_Beg;
          P_Gen_Type := 'O';
          P_Action.Detect_Operation_Template(P_Gen_Type     => P_Gen_Type,
                                             P_Template_Id  => P_Template_Id,
                                             P_Operation_Id => P_Operation_Id);
          -- Возвращает ID операции
          P_Base_Action.Create_Base_Action(P_Id                   => P_Action_Id,
                                           P_Action_Date          => P_Calendar.Get_Active_Day,
                                           P_Operation_Id         => P_Operation_Id,
                                           P_Is_Base              => 'T',
                                           P_Compound_Document_Id => Null,
                                           P_Action_Desc          => '');
          -- Получение суммы на on_get_amount
          P_Action_Amount := Nvl(P_Action.Get_Def_Operation_Amount(P_Operation_Id => P_Operation_Id,
                                                                   P_Contract_Id  => M_Contract_Info.Con_Id),
                                 0);
          -- Вызов для платежных операции
          P_Action.Do_Action_On_Create(P_Operation_Id       => P_Operation_Id,
                                       P_Contract_Id        => M_Contract_Info.Con_Id,
                                       P_Operation_No       => P_Operation_No,
                                       P_Action_Amount      => P_Action_Amount,
                                       P_Action_Currency_Id => M_Contract_Info.Cur_Id,
                                       P_Additional_Params  => P_Additional_Params);
          P_Action.Begin_Create_Action(P_RowId                => P_SR_RowId,
                                       P_Id                   => P_Action_Id,
                                       P_Operation_Id         => P_Operation_Id,
                                       P_Amount               => P_Action_Amount,
                                       P_Currency_Id          => M_Contract_Info.Cur_Id,
                                       P_Post_Date            => P_Calendar.Get_Active_Day,
                                       P_Doc_Date             => P_Calendar.Get_Active_Day,
                                       P_Description          => 'Регламентный вынос на просрочку единоразовой комиссии',
                                       P_Operation_No         => P_Operation_No,
                                       P_Compound_Document_Id => M_Contract_Info.Con_Id);
          P_Action.Exec_Generator_Acc_Array(P_Template_Id       => P_Template_Id,
                                            P_Macro_Array       => Id_Macro_Array,
                                            P_Account_Array     => Id_Account_Array,
                                            P_Additional_Params => P_Additional_Params);
          P_Action.End_Create_Action;
        
          -- Проводка сделки
          If P_Posted = 'T' Then
            P_Action.Post_Action(P_Action_Id, True);
            P_Base_Action.Notify_Action_Desc_Fmt('Успешное завершение по договору №' ||
                                                 M_Contract_Info.Doc_No);
          End If;
          Op_Co := Op_Co + 1;
          -- Обработка ошибок
        Exception
          When Others Then
            P_Base_Action.Notify_Action_Desc_Fmt('Ошибка по договору №' ||
                                                 M_Contract_Info.Doc_No);
            P_User_Output.Put_Line(Sqlerrm);
            P_End_Day.Save_Protocol_Error(Sqlerrm,
                                          P_Operation_Id,
                                          M_Contract_Info.Con_Id);
            Rollback To Tran_Beg;
        End;
      End If;
    End Loop;
    --возвращаем ту дату документов, которая была перед вызовом регламентной процедуры
    P_Contract.Set_Doc_Bank_Date(M_Old_Doc_Bank_Date);
  End;
  --открытие счетов единоразовых комиссий и просрочек, если это нужно
  Procedure On_Create_Auto_Open_Fee_Acc(P_Operation_Id         In Operation.Id%Type,
                                        P_Compound_Document_Id In Compound_Document.Id%Type,
                                        P_Operation_No         In Out Action.Operation_No%Type,
                                        P_Action_Amount        In Out Action.Amount%Type,
                                        P_Action_Currency_Id   In Out Action.Currency_Id%Type,
                                        P_Additional_Params    In Varchar2) Is
  Begin
    If FC_GB_Func_And_Proc.Do_Open_Acc_By_Local_Macro(P_Compound_Document_Id,
                                                      'CREDIT_MONO_FEE_3570') Then
      D_Credit_Operations.Create_Auto_Acc_For_Macro(P_Compound_Document_Id,
                                                    'CREDIT_MONO_FEE_3570');
    End If;
    If FC_GB_Func_And_Proc.Do_Open_Acc_By_Local_Macro(P_Compound_Document_Id,
                                                      'CREDIT_MONO_FEE_3579_1') Then
      D_Credit_Operations.Create_Auto_Acc_For_Macro(P_Compound_Document_Id,
                                                    'CREDIT_MONO_FEE_3579_1');
    End If;
    If FC_GB_Func_And_Proc.Do_Open_Acc_By_Local_Macro(P_Compound_Document_Id,
                                                      'CREDIT_MONO_FEE_3579_2') Then
      D_Credit_Operations.Create_Auto_Acc_For_Macro(P_Compound_Document_Id,
                                                    'CREDIT_MONO_FEE_3579_2');
    End If;
    If FC_GB_Func_And_Proc.Do_Open_Acc_By_Local_Macro(P_Compound_Document_Id,
                                                      'CREDIT_MONO_FEE_3589') Then
      D_Credit_Operations.Create_Auto_Acc_For_Macro(P_Compound_Document_Id,
                                                    'CREDIT_MONO_FEE_3589');
    End If;
  End;
  --Проверка участвуют ли счета, привязанные к договору в каких-либо других
  --договорах для вызова из пакетов
  Function Is_Contract_Accounts_Unique(P_Contract_Id Pls_Integer,
                                       Gen_Exception Boolean Default True)
    Return Boolean Is
    Acc_Str Varchar2(1024);
  Begin
    Acc_Str := Null;
    --по счетам остатков тела кредита проверим
    For Q In (Select C.Account_Id, A.Account_Number, Count(C.Contract_Id)
                From Contract_Account    C,
                     Account             A,
                     Credit_Document     CD,
                     Contract_Acc_Macro  CAM,
                     Generator_Acc_Macro GAM,
                     Contract            Com
               Where C.Account_Id In
                     (Select CA.Account_Id
                        From Contract_Account    CA,
                             Contract_Acc_Macro  CAM,
                             Generator_Acc_Macro GAM
                       Where CA.Contract_Id = P_Contract_Id
                         And CA.Macro_Id = CAM.Id
                         And CAM.Macro_Id = GAM.Id
                         And Trim(GAM.Sys_Name) In
                             ('CREDIT_REST', 'CREDIT_EXPIRE',
                              'CREDIT_REST_SUMN', 'CREDIT_DISCOUNT'))
                 And A.Id = C.Account_Id
                 And CD.Id = C.Contract_Id
                 And Com.Id = CD.Id
                 And Com.Close_Date Is Null
                 And CAM.Id = C.Macro_Id
                 And GAM.Id = CAM.Macro_Id
                 And GAM.Sys_Name Not In ('CUSTOMER_ACCOUNT')
               Group By C.Account_Id, A.Account_Number
              Having Count(C.Contract_Id) > 1) Loop
      Acc_Str := Acc_Str || Trim(Q.Account_Number) || Chr(13);
    End Loop;
    If Acc_Str Is Null Then
      --если нет счетов (курсор пуст), то счета договора уникальны
      Return True;
    Else
      --если есть счета (курсор не пуст), то счета договора участвуют в других договорах
      If Gen_Exception Then
        P_Exception.Raise_Common_Except('Счета ' || Acc_Str ||
                                        ' участвуют более, чем в одном договоре!!!');
      End If;
      Return False;
    End If;
  End;
  --Проверка участвуют ли счета, привязанные к договору в каких-либо других
  --договорах для вызова на втором уровне генератора на on_before или on_after
  Procedure Is_Contract_Accounts_Unique(P_Template_Id       In Generator_Template.Id%Type,
                                        P_Additional_Params In Varchar2) Is
    Res Boolean;
  Begin
    Res := Is_Contract_Accounts_Unique(P_Base_Action.Get_Current_Comp_Doc_Id);
  End;
  --занесение в историю параметров % ставок плавающей сетки
  Procedure Save_Interest_Range_To_Params(P_Con_Id Pls_Integer) Is
    P_Con_Info    P_Contract.Var_FullContract_Type%Type;
    Do_Type       Boolean;
    P_Mod_Type_Id Pls_Integer;
  Begin
    P_Con_Info := P_Contract.Get_Full_Contract_Params(P_Con_Id);
  
    Select Id
      Into P_Mod_Type_Id
      From Credit_Modify_Type
     Where Sys_Name = 'CREATE_DOC';
  
    Do_Type := True;
    For C In (Select *
                From Float_Percents FP
               Where FP.Contract_Id = P_Con_Id) Loop
      Do_Type := False;
      If C.Measure = 'D' Then
        --дни
        D_Credit.Modify_Param(P_Con_Id,
                              'INTEREST',
                              To_Char(C.Value, 'FM999999990.000000'),
                              P_Mod_Type_Id,
                              P_Con_Info.Begin_Date + C.Day_From - 1);
      Else
        --месяцы
        D_Credit.Modify_Param(P_Con_Id,
                              'INTEREST',
                              To_Char(C.Value, 'FM999999990.000000'),
                              P_Mod_Type_Id,
                              Add_Months(P_Con_Info.Begin_Date,
                                         C.Day_From - 1));
      End If;
    End Loop;
    If Do_Type Then
      For T In (Select *
                  From Type_Float_Percents FP
                 Where FP.Contract_Type_Id = P_Con_Info.Type_Id) Loop
        If T.Measure = 'D' Then
          --дни
          D_Credit.Modify_Param(P_Con_Id,
                                'INTEREST',
                                To_Char(T.Value, 'FM999999990.000000'),
                                P_Mod_Type_Id,
                                P_Con_Info.Begin_Date + T.Day_From - 1);
        Else
          --месяцы
          D_Credit.Modify_Param(P_Con_Id,
                                'INTEREST',
                                To_Char(T.Value, 'FM999999990.000000'),
                                P_Mod_Type_Id,
                                Add_Months(P_Con_Info.Begin_Date,
                                           T.Day_From - 1));
        End If;
      End Loop;
    End If;
  End;
  --Удаление договора (удалим записи о плавающих процентных ставках)
  Procedure On_Delete_Open_Doc(P_Id In Base_Action.Id%Type) Is
    P_Con_Id   Pls_Integer;
    P_Con_Info P_Contract.Var_FullContract_Type%Type;
    Do_Type    Boolean;
  Begin
    P_Con_Id   := P_Action.Get_Comp_Doc_Id(P_Id);
    P_Con_Info := P_Contract.Get_Full_Contract_Params(P_Con_Id);
    Do_Type    := True;
    --удалим то, что мы жобавили (если добавили :))
    For C In (Select *
                From Float_Percents FP
               Where FP.Contract_Id = P_Con_Id
                 And FP.Day_From <>
                     (Select Min(Day_From)
                        From Float_Percents
                       Where Contract_Id = P_Con_Id)) Loop
      Do_Type := False;
      If C.Measure = 'D' Then
        --дни
        Delete From Credit_Param_History CPH
         Where CPH.Credit_Id = P_Con_Id
           And CPH.Param = 'INTEREST'
           And CPH.Modify_Bank_Date =
               P_Con_Info.Begin_Date + C.Day_From - 1;
      Else
        --месяцы
        Delete From Credit_Param_History CPH
         Where CPH.Credit_Id = P_Con_Id
           And CPH.Param = 'INTEREST'
           And CPH.Modify_Bank_Date =
               Add_Months(P_Con_Info.Begin_Date, C.Day_From - 1);
      End If;
    End Loop;
    If Do_Type Then
      For T In (Select *
                  From Type_Float_Percents FP
                 Where FP.Contract_Type_Id = P_Con_Info.Type_Id
                   And FP.Day_From <>
                       (Select Min(Day_From)
                          From Type_Float_Percents
                         Where Contract_Type_Id = P_Con_Info.Type_Id)) Loop
        If T.Measure = 'D' Then
          --дни
          Delete From Credit_Param_History CPH
           Where CPH.Credit_Id = P_Con_Id
             And CPH.Param = 'INTEREST'
             And CPH.Modify_Bank_Date =
                 P_Con_Info.Begin_Date + T.Day_From - 1;
        Else
          --месяцы
          Delete From Credit_Param_History CPH
           Where CPH.Credit_Id = P_Con_Id
             And CPH.Param = 'INTEREST'
             And CPH.Modify_Bank_Date =
                 Add_Months(P_Con_Info.Begin_Date, T.Day_From - 1);
        End If;
      End Loop;
    End If;
    --вызов стандартной процедуры
    D_Credit_Generator.On_Delete_Open(P_Id);
  End;
  --отмена начисления по плавающей ставке
  Procedure No_Range_Pcnt(P_Template_Id       In Generator_Template.Id%Type,
                          P_Additional_Params In Varchar2) Is
    P_Mod_Type_Id Pls_Integer;
    P_Int_Body    Number;
    P_Int_Expire  Number;
    Cursor Get_Doc_Int(P_Id Pls_Integer) Is
      Select Cd.Interest From Credit_Document Cd Where Cd.Id = P_Id;
    P_Con_Interest Number;
    Cursor Get_Agreement_Hist(P_Id Pls_Integer) Is
      Select CPH.Add_Agreement
        From Credit_Param_History CPH
       Where CPH.Id = P_Id;
    P_Add_Agreement Credit_Param_History.Add_Agreement%Type;
    P_Int_Param_Id  Pls_Integer;
    L_Begin_Date Date;
  Begin
    If P_Params_Translator.Get_Str_Param(P_Additional_Params,
                                         'PRICHINA',
                                         False) Is Null Then
      If Abs(P_Rest_Engine.Get_Account_Rest(P_Contract.Get_Acc_Id_By_Macro(P_Base_Action.Get_Current_Comp_Doc_Id,
                                                                           'CREDIT_EXPIRE'),
                                            P_Contract.Get_Doc_Bank_Date)) = 0 Then
        P_Exception.Raise_Common_Except('Над данным договором операция не выполняется - нет остатка на просрочке!');
      End If;
    End If;
    --дата начала действия новой процентной ставки
    L_Begin_Date:=P_Params_Translator.Get_Dat_Param(P_Additional_Params,'P_NEW_INT_DATE',False);
    L_Begin_Date:=Nvl(L_Begin_Date,P_Contract.Get_Doc_Bank_Date);
    --получим проценты с договора
    Open Get_Doc_Int(P_Base_Action.Get_Current_Comp_Doc_Id);
    Fetch Get_Doc_Int
      Into P_Con_Interest;
    Close Get_Doc_Int;
    --удалим из параметров все последующие процентные ставки
    Delete From Credit_Param_History CPH
     Where CPH.Credit_Id = P_Base_Action.Get_Current_Comp_Doc_Id
       And CPH.Param = 'INTEREST'
       And CPH.Modify_Bank_Date >= L_Begin_Date;
  
    Delete From Credit_Param_History CPH
     Where CPH.Credit_Id = P_Base_Action.Get_Current_Comp_Doc_Id
       And CPH.Param = 'INT_PART_EXPIRE'
       And CPH.Modify_Bank_Date >= L_Begin_Date;
  
    Select Id
      Into P_Mod_Type_Id
      From Credit_Modify_Type
     Where Sys_Name = 'ADD_AGREEMENT';
    --получим что написано в тексте допсоглашения
    P_Add_Agreement := Null;
    Begin
      Open Get_Agreement_Hist(D_Credit.Get_Param_History_Id(P_Base_Action.Get_Current_Comp_Doc_Id,
                                                            L_Begin_Date,
                                                            'INTEREST'));
      Fetch Get_Agreement_Hist
        Into P_Add_Agreement;
      Close Get_Agreement_Hist;
    Exception
      When Others Then
        Null;
    End;
    --занесем в историю параметров новые % ставки
    P_Int_Body := P_Params_Translator.Get_Num_Param(P_Additional_Params,
                                                    'INT_BODY',
                                                    False);
    If P_Int_Body Is Null Then
      If (InStr(P_Add_Agreement, 'EXTRA_INTEREST') = 0) Or
         (P_Add_Agreement Is Null) Then
        --если клиент еще не живет с повышенной ставкой, то повысим ее
        P_Int_Body := To_Number_Safe(Nvl(D_Credit.Get_Param_Hist_Value(L_Begin_Date,
                                                                       P_Base_Action.Get_Current_Comp_Doc_Id,
                                                                       'INTEREST'),
                                         P_Con_Interest)) + 1;
      End If;
    End If;
    P_Int_Expire := P_Params_Translator.Get_Num_Param(P_Additional_Params,
                                                      'INT_EXPIRE',
                                                      False);
    If P_Int_Expire Is Null Then
      --если нет параметра - приравниваем к процентам по телу
      P_Int_Expire := P_Int_Body;
    End If;
    If (P_Int_Body Is Not Null) And (P_Int_Expire Is Not Null) Then
      D_Credit.Modify_Param(P_Base_Action.Get_Current_Comp_Doc_Id,
                            'INTEREST',
                            To_Char(P_Int_Body, 'FM999999990.000000'),
                            P_Mod_Type_Id,
                            L_Begin_Date);
      --проставим признак работы по повышенной ставке (введенной вручную)
      P_Int_Param_Id := D_Credit.Get_Param_History_Id(P_Base_Action.Get_Current_Comp_Doc_Id,
                                                      L_Begin_Date,
                                                      'INTEREST');
      Update Credit_Param_History CPH
         Set CPH.Add_Agreement = CPH.Add_Agreement || 'EXTRA_INTEREST'
       Where CPH.Id = P_Int_Param_Id;
      D_Credit.Modify_Param(P_Base_Action.Get_Current_Comp_Doc_Id,
                            'INT_PART_EXPIRE',
                            To_Char(P_Int_Expire, 'FM999999990.000000'),
                            P_Mod_Type_Id,
                            L_Begin_Date);
      --проставим признак работы по повышенной ставке (введенной вручную)
      P_Int_Param_Id := D_Credit.Get_Param_History_Id(P_Base_Action.Get_Current_Comp_Doc_Id,
                                                      L_Begin_Date,
                                                      'INT_PART_EXPIRE');
      Update Credit_Param_History CPH
         Set CPH.Add_Agreement = CPH.Add_Agreement || 'EXTRA_INTEREST'
       Where CPH.Id = P_Int_Param_Id;
      P_Base_Action.Notify_Action_Desc('Удалены процентные ставки с датой более ' ||
                                       To_Char(L_Begin_Date,
                                               'DD.MM.YYYY') || Chr(13) ||
                                       'Установлены новые процентные ставки:' ||
                                       Chr(13) || 'INTEREST - ' ||
                                       To_Char(P_Int_Body,
                                               'FM999999990.000000') ||
                                       Chr(13) || 'INT_PART_EXPIRE - ' ||
                                       To_Char(P_Int_Expire,
                                               'FM999999990.000000'));
    End If;
  End;
  --вернем на начисление по плаваюей ставке
  Procedure Yes_Range_Pcnt(P_Template_Id       In Generator_Template.Id%Type,
                           P_Additional_Params In Varchar2) Is
    P_Con_Info    P_Contract.Var_FullContract_Type%Type;
    Do_Type       Boolean;
    P_Mod_Type_Id Pls_Integer;
    L_Begin_Date Date;
  Begin
    P_Con_Info := P_Contract.Get_Full_Contract_Params(P_Base_Action.Get_Current_Comp_Doc_Id);
    --дата начала действия новой процентной ставки
    L_Begin_Date:=P_Params_Translator.Get_Dat_Param(P_Additional_Params,'P_NEW_INT_DATE',False);
    L_Begin_Date:=Nvl(L_Begin_Date,P_Contract.Get_Doc_Bank_Date);
  
    Select Id
      Into P_Mod_Type_Id
      From Credit_Modify_Type
     Where Sys_Name = 'ADD_AGREEMENT';
  
    --удалим из параметров все последующие процентные ставки
    Delete From Credit_Param_History CPH
     Where CPH.Credit_Id = P_Base_Action.Get_Current_Comp_Doc_Id
       And CPH.Param = 'INTEREST'
       And CPH.Modify_Bank_Date >= L_Begin_Date;
  
    Delete From Credit_Param_History CPH
     Where CPH.Credit_Id = P_Base_Action.Get_Current_Comp_Doc_Id
       And CPH.Param = 'INT_PART_EXPIRE'
       And CPH.Modify_Bank_Date >= L_Begin_Date;
    --заполнение параметров
    Do_Type := True;
    For C In (Select *
                From Float_Percents FP
               Where FP.Contract_Id = P_Con_Info.Id) Loop
      Do_Type := False;
      If C.Measure = 'D' Then
        --дни
        If L_Begin_Date <=
           P_Con_Info.Begin_Date + C.Day_To - 1 Then
          --добавляем только то, что больше текущей даты
          If L_Begin_Date <=
             P_Con_Info.Begin_Date + C.Day_From - 1 Then
            D_Credit.Modify_Param(P_Con_Info.Id,
                                  'INTEREST',
                                  To_Char(C.Value, 'FM999999990.000000'),
                                  P_Mod_Type_Id,
                                  P_Con_Info.Begin_Date + C.Day_From - 1);
          Else
            D_Credit.Modify_Param(P_Con_Info.Id,
                                  'INTEREST',
                                  To_Char(C.Value, 'FM999999990.000000'),
                                  P_Mod_Type_Id,
                                  L_Begin_Date);
          End If;
        End If;
      Else
        --месяцы
        If L_Begin_Date <=
           Add_Months(P_Con_Info.Begin_Date, C.Day_To - 1) Then
          --добавляем только то, что больше текущей даты
          If L_Begin_Date <=
             Add_Months(P_Con_Info.Begin_Date, C.Day_From - 1) Then
            D_Credit.Modify_Param(P_Con_Info.Id,
                                  'INTEREST',
                                  To_Char(C.Value, 'FM999999990.000000'),
                                  P_Mod_Type_Id,
                                  Add_Months(P_Con_Info.Begin_Date,
                                             C.Day_From - 1));
          Else
            D_Credit.Modify_Param(P_Con_Info.Id,
                                  'INTEREST',
                                  To_Char(C.Value, 'FM999999990.000000'),
                                  P_Mod_Type_Id,
                                  L_Begin_Date);
          End If;
        End If;
      End If;
    End Loop;
    --настройки с типа
    If Do_Type Then
      For T In (Select *
                  From Type_Float_Percents FP
                 Where FP.Contract_Type_Id = P_Con_Info.Type_Id) Loop
        Do_Type := False;
        If T.Measure = 'D' Then
          --дни
          If L_Begin_Date <=
             P_Con_Info.Begin_Date + T.Day_To - 1 Then
            --добавляем только то, что больше текущей даты
            If L_Begin_Date <=
               P_Con_Info.Begin_Date + T.Day_From - 1 Then
              D_Credit.Modify_Param(P_Con_Info.Id,
                                    'INTEREST',
                                    To_Char(T.Value, 'FM999999990.000000'),
                                    P_Mod_Type_Id,
                                    P_Con_Info.Begin_Date + T.Day_From - 1);
            Else
              D_Credit.Modify_Param(P_Con_Info.Id,
                                    'INTEREST',
                                    To_Char(T.Value, 'FM999999990.000000'),
                                    P_Mod_Type_Id,
                                    L_Begin_Date);
            End If;
          End If;
        Else
          --месяцы
          If L_Begin_Date <=
             Add_Months(P_Con_Info.Begin_Date, T.Day_To - 1) Then
            --добавляем только то, что больше текущей даты
            If L_Begin_Date <=
               Add_Months(P_Con_Info.Begin_Date, T.Day_From - 1) Then
              D_Credit.Modify_Param(P_Con_Info.Id,
                                    'INTEREST',
                                    To_Char(T.Value, 'FM999999990.000000'),
                                    P_Mod_Type_Id,
                                    Add_Months(P_Con_Info.Begin_Date,
                                               T.Day_From - 1));
            Else
              D_Credit.Modify_Param(P_Con_Info.Id,
                                    'INTEREST',
                                    To_Char(T.Value, 'FM999999990.000000'),
                                    P_Mod_Type_Id,
                                    L_Begin_Date);
            End If;
          End If;
        End If;
      End Loop;
    End If;
    If Do_Type Then
      P_Exception.Raise_Common_Except('На договоре не настроена процентная сетка!');
    End If;
    P_Base_Action.Notify_Action_Desc('Выполнена настройка плавающей ставки!');
  End;

  --madcap
  Procedure On_Bef_Get_Mono_Amount(P_Template_Id       In Generator_Template.Id%Type,
                                   P_Additional_Params In Varchar2) is
    P_Con_Info P_Contract.Var_Fullcontract_Type%Type;
    P_3570     Number(38, 2);
    P_3579_1   Number(38, 2);
    P_3579_2   Number(38, 2);
    P_3589     Number(38, 2);
    p_amount   number(38, 2);
  Begin
    --получение необходимых параметров
    P_Con_Info := P_Contract.Get_Full_Contract_Params(P_Base_Action.Get_Current_Comp_Doc_Id);
    --остатки на счетах
    P_3570   := Nvl(P_Rest_Engine.Get_Account_Rest(P_Contract.Get_Acc_Id_By_Macro(P_Con_Info.Id,
                                                                                  'CREDIT_MONO_FEE_3570'),
                                                   P_Contract.Get_Doc_Bank_Date),
                    0);
    P_3579_1 := Nvl(P_Rest_Engine.Get_Account_Rest(P_Contract.Get_Acc_Id_By_Macro(P_Con_Info.Id,
                                                                                  'CREDIT_MONO_FEE_3579_1'),
                                                   P_Contract.Get_Doc_Bank_Date),
                    0);
    P_3579_2 := Nvl(P_Rest_Engine.Get_Account_Rest(P_Contract.Get_Acc_Id_By_Macro(P_Con_Info.Id,
                                                                                  'CREDIT_MONO_FEE_3579_2'),
                                                   P_Contract.Get_Doc_Bank_Date),
                    0);
    P_3589   := Nvl(P_Rest_Engine.Get_Account_Rest(P_Contract.Get_Acc_Id_By_Macro(P_Con_Info.Id,
                                                                                  'CREDIT_MONO_FEE_3589'),
                                                   P_Contract.Get_Doc_Bank_Date),
                    0);
    --сумма операции
    p_amount := p_action.get_action_amount(p_base_action.get_current_action_id);
    --суммы для каждого шага
    if p_amount > 0 then
      if p_amount > p_3589 then
        FC_GB_Func_And_Proc.M_Sums(1) := 0;
        FC_GB_Func_And_Proc.M_Sums(2) := P_3589;
        FC_GB_Func_And_Proc.M_Sums(3) := 0;
        FC_GB_Func_And_Proc.M_Sums(4) := 0;
        FC_GB_Func_And_Proc.M_Sums(5) := 0;
      else
        FC_GB_Func_And_Proc.M_Sums(1) := 0;
        FC_GB_Func_And_Proc.M_Sums(2) := p_amount;
        FC_GB_Func_And_Proc.M_Sums(3) := 0;
        FC_GB_Func_And_Proc.M_Sums(4) := 0;
        FC_GB_Func_And_Proc.M_Sums(5) := 0;
      end if;
      p_amount := p_amount - P_3589;
    
      if p_amount > P_3579_2 then
        FC_GB_Func_And_Proc.M_Sums(1) := 0;
        FC_GB_Func_And_Proc.M_Sums(3) := P_3579_2;
        FC_GB_Func_And_Proc.M_Sums(4) := 0;
        FC_GB_Func_And_Proc.M_Sums(5) := 0;
      else
        FC_GB_Func_And_Proc.M_Sums(1) := 0;
        FC_GB_Func_And_Proc.M_Sums(3) := p_amount;
        FC_GB_Func_And_Proc.M_Sums(4) := 0;
        FC_GB_Func_And_Proc.M_Sums(5) := 0;
      end if;
      p_amount := p_amount - P_3579_2;
    
      if p_amount > P_3579_1 then
        FC_GB_Func_And_Proc.M_Sums(1) := 0;
        FC_GB_Func_And_Proc.M_Sums(4) := P_3579_1;
        FC_GB_Func_And_Proc.M_Sums(5) := 0;
      else
        FC_GB_Func_And_Proc.M_Sums(1) := 0;
        FC_GB_Func_And_Proc.M_Sums(4) := p_amount;
        FC_GB_Func_And_Proc.M_Sums(5) := 0;
      end if;
      p_amount := p_amount - P_3579_1;
    
      if p_amount > P_3570 then
        FC_GB_Func_And_Proc.M_Sums(1) := 0;
        FC_GB_Func_And_Proc.M_Sums(5) := P_3570;
      else
        FC_GB_Func_And_Proc.M_Sums(1) := 0;
        FC_GB_Func_And_Proc.M_Sums(5) := p_amount;
      end if;
      p_amount := p_amount - P_3570;
    
      if p_amount > 0 then
        p_exception.raise_common_except('Сумма операции больше задолженности  по единоразовой комиссии!!!');
      end if;
    else
      FC_GB_Func_And_Proc.M_Sums(2) := 0;
      FC_GB_Func_And_Proc.M_Sums(3) := 0;
      FC_GB_Func_And_Proc.M_Sums(4) := 0;
      FC_GB_Func_And_Proc.M_Sums(5) := 0;
    end if;
  end;

  --Вынос на просрочку единоразовой комиссии
  Function Oper$Get_Mono_Amount_Expire(P_Operation_Id         In Operation.Id%Type,
                                       P_Compound_Document_Id In Compound_Document.Id%Type)
    Return Number is
    P_Date_Expire Date;
    Dist_In_Days  Pls_Integer;
    P_Con_Info    P_Contract.Var_Fullcontract_Type%Type;
    P_3570        Number(38, 2);
    P_3579_1      Number(38, 2);
    P_3579_2      Number(38, 2);
    P_3589        Number(38, 2);
  Begin
    --получение необходимых параметров
    P_Con_Info := P_Contract.Get_Full_Contract_Params(P_Base_Action.Get_Current_Comp_Doc_Id);
    P_3570     := Nvl(P_Rest_Engine.Get_Account_Rest(P_Contract.Get_Acc_Id_By_Macro(P_Con_Info.Id,
                                                                                    'CREDIT_MONO_FEE_3570'),
                                                     P_Contract.Get_Doc_Bank_Date),
                      0);
    P_3579_1   := Nvl(P_Rest_Engine.Get_Account_Rest(P_Contract.Get_Acc_Id_By_Macro(P_Con_Info.Id,
                                                                                    'CREDIT_MONO_FEE_3579_1'),
                                                     P_Contract.Get_Doc_Bank_Date),
                      0);
    P_3579_2   := Nvl(P_Rest_Engine.Get_Account_Rest(P_Contract.Get_Acc_Id_By_Macro(P_Con_Info.Id,
                                                                                    'CREDIT_MONO_FEE_3579_2'),
                                                     P_Contract.Get_Doc_Bank_Date),
                      0);
    P_3589     := Nvl(P_Rest_Engine.Get_Account_Rest(P_Contract.Get_Acc_Id_By_Macro(P_Con_Info.Id,
                                                                                    'CREDIT_MONO_FEE_3589'),
                                                     P_Contract.Get_Doc_Bank_Date),
                      0);
    --если не первая просрочка не учитываем выходные дни                                       
    if P_3579_1 + P_3579_2 + P_3589 > 0 then
      Dist_In_Days := Trunc(trunc(P_Contract.Get_Doc_Bank_Date) - 1) -
                      Trunc(P_Con_Info.Begin_Date);
    else
      Dist_In_Days := Trunc(Fc_Gb_Func_And_Proc.Get_Last_Work_Day(P_Contract.Get_Doc_Bank_Date)) -
                      Trunc(P_Con_Info.Begin_Date);
    end if;
  
    If (Dist_In_Days >= 1) And (Dist_In_Days < 31) And (P_3570 <> 0) Then
      --если первая просрочка (2 дня) Дт 3579_1 - Кт 3570
      FC_GB_Func_And_Proc.M_Sums(1) := 0;
      FC_GB_Func_And_Proc.M_Sums(2) := 0;
      FC_GB_Func_And_Proc.M_Sums(3) := P_3570;
    ElsIf (Dist_In_Days >= 31) And (Dist_In_Days < 61) And (P_3579_1 <> 0) Then
      --если вторая просрочка (до 32 дней) Дт 3579_2 - Кт 3579_1
      FC_GB_Func_And_Proc.M_Sums(1) := 0;
      FC_GB_Func_And_Proc.M_Sums(2) := P_3579_1;
      FC_GB_Func_And_Proc.M_Sums(3) := 0;
    ElsIf (Dist_In_Days >= 61) And (P_3579_2 <> 0) Then
      --Если перенос в Сомнительные (свыше 62 дней) Дт 3589 - Кт 3579_2
      FC_GB_Func_And_Proc.M_Sums(1) := P_3579_2;
      FC_GB_Func_And_Proc.M_Sums(2) := 0;
      FC_GB_Func_And_Proc.M_Sums(3) := 0;
    Else
      --если ничего не подходит - нет просрочки
      FC_GB_Func_And_Proc.M_Sums(1) := 0;
      FC_GB_Func_And_Proc.M_Sums(2) := 0;
      FC_GB_Func_And_Proc.M_Sums(3) := 0;
    End If;
    --p_exception.raise_common_except(Dist_In_Days);
    return FC_GB_Func_And_Proc.M_Sums(1) + FC_GB_Func_And_Proc.M_Sums(2) + FC_GB_Func_And_Proc.M_Sums(3);
  end;

  function oper$get_cash_out(p_operation_id         pls_integer,
                             p_compound_document_id pls_integer)
    return number is
  
    m_contr_info        p_contract.var_fullcontract_type%type;
    m_res               Number(38, 2);
    m_parent_contr_info p_contract.var_fullcontract_type%type;
    m_date              date;
  
  Begin
  
    m_contr_info        := p_contract.get_full_contract_params(P_Compound_Document_Id);
    m_parent_contr_info := p_contract.get_full_contract_params(m_contr_info.parent_id);
    m_res               := 0;
    m_date              := p_contract.get_doc_bank_date;
  
    If M_Contr_Info.Contract_Mode = 2 Then
      --если родительский
      m_res := Abs(Nvl(P_Contract.Get_Account_Amount(P_Contract.Get_Acc_Id_By_Macro(P_Compound_Document_Id,
                                                                                    'CREDIT_LIMIT')),
                       0));
    elsif M_Contr_Info.Contract_Mode = 3 Then
      --если линия
      m_res := Abs(Nvl(p_rest_engine.get_account_base_rest(P_Contract.Get_Acc_Id_By_Macro(m_parent_contr_info.id,
                                                                                          'CREDIT_LIMIT'),
                                                           m_date),
                       0));
    
      --переводим в валюту линии       
      if m_contr_info.currency_id <>
         p_registry.get_integer_value('\COMMON', 'CURRENCY_ID') then
      
        m_res := round(m_res /
                       p_currency.get_kurs(m_contr_info.currency_id,
                                           p_contract.get_doc_bank_date),
                       2);
      
      end if;
    
      -- сумма операции = сумма договора линии но не больше лимита
      if m_contr_info.begin_amount < m_res then
        m_res := m_contr_info.begin_amount;
      end if;
    Else
      m_res := m_contr_info.begin_amount;
    End If;
    Return(m_res);
  end;

  function gen$get_cash_out(p_currency_id in currency.id%type,
                            p_amount      in action.amount%type,
                            p_step_id     in gen_template_step.id%type,
                            p_action_id   in action.id%type) return number is
    M_Contr_Info P_Contract.Var_Fullcontract_Type%Type;
    m_res        Number(38, 2);
  Begin
    M_Contr_Info := P_Contract.Get_Full_Contract_Params(p_base_action.get_current_comp_doc_id);
    m_res        := 0;
    If M_Contr_Info.Contract_Mode = 2 or M_Contr_Info.Contract_Mode = 3 Then
      --если родительский или линия
      m_res := oper$get_cash_out(null, M_Contr_Info.id);
      if p_amount > m_res then
        p_exception.raise_common_except('Превышен мультивалутый лимит кредитования в сумме ' ||
                                        to_char(p_amount - m_res,
                                                'FM9999999999990.00') ||
                                        '!!!');
      end if;
    end if;
    return p_amount;
  end;

  function oper$get_cash_out_gb(p_operation_id         pls_integer,
                                p_compound_document_id pls_integer)
    return number is
  
    m_contr_info        p_contract.var_fullcontract_type%type;
    m_res               Number(38, 2);
    m_parent_contr_info p_contract.var_fullcontract_type%type;
    m_date              date;
  Begin
  
    m_contr_info        := p_contract.get_full_contract_params(P_Compound_Document_Id);
    m_parent_contr_info := p_contract.get_full_contract_params(m_contr_info.parent_id);
    m_res               := 0;
    m_date              := p_contract.get_doc_bank_date;
  
    If M_Contr_Info.Contract_Mode = 2 Then
      --если родительский
      m_res := Abs(Nvl(P_Contract.Get_Account_Amount(P_Contract.Get_Acc_Id_By_Macro(P_Compound_Document_Id,
                                                                                    'CREDIT_LIMIT')),
                       0));
    elsif M_Contr_Info.Contract_Mode = 3 Then
      --если линия
      m_res := Abs(Nvl(p_rest_engine.get_account_base_rest(P_Contract.Get_Acc_Id_By_Macro(m_parent_contr_info.id,
                                                                                          'CREDIT_LIMIT'),
                                                           m_date),
                       0));
    
      --переводим в валюту линии       
      if m_contr_info.currency_id <>
         p_registry.get_integer_value('\COMMON', 'CURRENCY_ID') then
      
        m_res := round(m_res /
                       p_currency.get_kurs(m_contr_info.currency_id,
                                           p_contract.get_doc_bank_date),
                       2);
      
      end if;
      -- сумма операции = сумма договора линии но не больше лимита
      if m_contr_info.begin_amount < m_res then
        m_res := oper_am$fc_gb_cred_out(p_operation_id,
                                        p_compound_document_id);
      end if;
    Else
      m_res := oper_am$fc_gb_cred_out(p_operation_id,
                                      p_compound_document_id);
    End If;
    Return(m_res);
  end;

  function gen$get_cash_out_gb(p_currency_id in currency.id%type,
                               p_amount      in action.amount%type,
                               p_step_id     in gen_template_step.id%type,
                               p_action_id   in action.id%type) return number is
    M_Contr_Info P_Contract.Var_Fullcontract_Type%Type;
    m_res        Number(38, 2);
  Begin
    M_Contr_Info := P_Contract.Get_Full_Contract_Params(p_base_action.get_current_comp_doc_id);
    m_res        := 0;
    If M_Contr_Info.Contract_Mode = 2 or M_Contr_Info.Contract_Mode = 3 Then
      --если родительский или линия
      m_res := oper$get_cash_out_gb(null, M_Contr_Info.id);
      if p_amount > m_res then
        p_exception.raise_common_except('Превышен мультивалутый лимит кредитования в сумме ' ||
                                        to_char(p_amount - m_res,
                                                'FM9999999999990.00') ||
                                        '!!!');
      end if;
    end if;
    return p_amount;
  end;

  --end madcap 

  -- Средние для активных остатков (с учетом 0) добавлено ФИК 21,03,2008
  function get_account_rest_avg(p_account_id pls_integer,
                                p_begin_date date,
                                p_end_date   date,
                                p_all_posts  varchar2 := 'F') return number is
    p_rest_list      p_types.NumberListType;
    p_base_rest_list p_types.NumberListType;
    p_sum            number;
    p_count          pls_integer := p_end_date - p_begin_date + 1;
  
    p_result account.amount%type;
  begin
    p_sum   := 0;
    p_count := 0;
  
    p_rest_engine.load_account_rest_list(p_account_id,
                                         p_begin_date,
                                         p_end_date,
                                         p_rest_list,
                                         p_base_rest_list,
                                         p_all_posts);
    for i in 1 .. p_rest_list.count loop
    
      p_count := p_count + 1;
      p_sum   := p_sum + p_rest_list(i);
    
    end loop;
    --p_exception.raise_common_except(to_char(p_begin_date)||' '||to_char(p_end_date));
    if p_count > 0 then
      p_result := round(ABS(p_sum) / p_count, 2);
    else
      p_result := 0;
    end if;
  
    return p_result;
  end;

  --сумма и сторнирование начисленных % на тело и просроченную часть
  Procedure On_Create_Int_Storno_Total(P_Operation_Id         In Operation.id%Type,
                                       P_Compound_Document_Id In Compound_Action.Compound_Document_Id%Type,
                                       P_Operation_No         In Out Action.Operation_No%Type,
                                       P_Action_Amount        In Out Action.Amount%Type,
                                       P_Action_Currency_Id   In Out Action.Currency_Id%Type,
                                       P_Additional_Params    In Varchar2) Is
    M_Act_Amount            Number;
    P_Object_Id             Pls_Integer;
    P_Begin_Date_Storno_Ext Date;
    P_End_Date_Storno_Ext   Date;
    Cursor IntCur(P_Obj_Id Pls_Integer, P_Date_Storno Date) Is
      Select Min(I.Calc_Date) Begin_Date,
             Max(I.Calc_Date) End_Date,
             Sum(I.Amount) Amount
        From Interest_Calc i
       Where I.Object_Id = P_Obj_Id
         And I.Is_Close = 'T'
         And I.Calc_Date > P_Date_Storno
         And I.Calc_Type In
             ('EXPIRE_R_FOR_MACRO_CRED', 'INT_PART_EXPIRE_CRED');
    IntRec IntCur%RowType;
  Begin
    P_Action_Amount := 0;
    M_Act_Amount    := 0;
    --вызов стандартной функции сторно на тело кредита
    D_Credit_Generator.On_Create_Int_Storno(P_Operation_Id         => P_Operation_Id,
                                            P_Compound_Document_Id => P_Compound_Document_Id,
                                            P_Operation_No         => P_Operation_No,
                                            P_Action_Amount        => M_Act_Amount,
                                            P_Action_Currency_Id   => P_Action_Currency_Id,
                                            P_Additional_Params    => P_Additional_Params);
    P_Action_Amount := P_Action_Amount + Round(M_Act_Amount, 2);
    P_Interest.Detect_Object(P_Compound_Document_Id, P_Object_Id, 'CREDIT');
    IntRec := Null;
    Open IntCur(P_Object_Id,
                P_Params_Translator.Get_Dat_Param(P_Additional_Params,
                                                  'P_DATE_STORNO'));
    Fetch IntCur
      Into IntRec;
    Close IntCur;
    --если есть сумма % начисленных на просроченную часть
    If (IntRec.Amount <> 0) And (IntRec.Amount Is Not Null) Then
      P_Begin_Date_Storno_Ext := IntRec.Begin_Date;
      P_End_Date_Storno_Ext   := IntRec.End_Date;
      M_Act_Amount            := IntRec.Amount;
      If P_Begin_Date_Storno_Ext Is Not Null Then
        -- Сохраняем дату начала периода для сторно по календарю прочих начислений
        P_Base_Action.Create_Action_Addrem(P_Base_Action_Id => P_Base_Action.Get_Current_Action_Id,
                                           P_Param          => 'BEGIN_DATE_STORNO_EXT',
                                           P_Value          => To_Char(P_Begin_Date_Storno_Ext,
                                                                       'DD.MM.YYYY'),
                                           P_Type           => 'DAT',
                                           P_Is_Param       => 'F');
        -- Сохраняем дату окончания периода для сторно
        p_base_action.create_action_addrem(P_Base_Action_Id => P_Base_Action.Get_Current_Action_Id,
                                           P_Param          => 'END_DATE_STORNO_EXT',
                                           P_Value          => To_Char(P_End_Date_Storno_Ext,
                                                                       'DD.MM.YYYY'),
                                           P_Type           => 'DAT',
                                           P_Is_Param       => 'F');
        --снимем признак закрытого периода
        Update Interest_Calc I
           Set I.Is_Close = 'F'
         Where I.Object_Id = P_Object_Id
           And I.Is_Close = 'T'
           And I.Calc_Date >= P_Begin_Date_Storno_Ext
           And I.Calc_Date < P_End_Date_Storno_Ext + 1
           And I.Calc_Type In
               ('EXPIRE_R_FOR_MACRO_CRED', 'INT_PART_EXPIRE_CRED');
        --увеличим сумм операции на сумму из календаря прочих начислений
        M_Act_Amount    := Round(M_Act_Amount, 2);
        P_Action_Amount := P_Action_Amount + M_Act_Amount;
        P_Base_Action.Notify_Action_Desc_FMT('Сторно % на просроченную часть на сумму %s c %s по %s',
                                             M_Act_Amount,
                                             P_Begin_Date_Storno_Ext,
                                             P_End_Date_Storno_Ext);
      End If;
    End If;
  End;
  --Операция обратная сторнированию % вызывается при удалении операции сторнирования
  Procedure On_Delete_Int_Storno_Total(P_Id In Base_Action.Id%Type) Is
    P_Param    Action_Addrem.Param%Type;
    P_Value    Action_Addrem.Value%Type;
    P_Type     Action_Addrem.Type%Type;
    P_Is_Param Action_Addrem.Is_Param%Type;
  
    P_Begin_Date Date;
    P_End_Date   Date;
  
    P_Object_Id Pls_Integer;
    P_Cred_Id   Credit_Document.Id%Type;
  Begin
    --вызов стандартной процедуры при удалении операции сторнирования % на тело кредита
    D_Credit_Generator.On_Delete_Int_Storno(P_Id);
    --отмена сторно начисленных % на просроченную часть тела
    P_Cred_Id := P_Get_Params.Get_Contr_By_Base_Id(P_Base_Action_Id => P_Id);
    P_Interest.Detect_Object(P_Cred_Id, P_Object_Id, 'CREDIT');
    -- Получение дипазона дат для закрытия календаря
    P_Param := 'BEGIN_DATE_STORNO_EXT';
    P_Base_Action.Get_Value_Action_Addrem(P_Base_Action_Id => P_Id,
                                          P_Param          => P_Param,
                                          P_Value          => P_Value,
                                          P_Type           => P_Type,
                                          P_Is_Param       => P_Is_Param);
    P_Begin_Date := To_Date(P_Value, 'DD.MM.YYYY');
  
    P_Param := 'END_DATE_STORNO_EXT';
    P_Base_Action.Get_Value_Action_Addrem(P_Base_Action_Id => P_Id,
                                          P_Param          => P_Param,
                                          P_Value          => P_Value,
                                          P_Type           => P_Type,
                                          P_Is_Param       => P_Is_Param);
    P_End_Date := To_Date(P_Value, 'DD.MM.YYYY');
    --если есть что отменять
    If P_Begin_Date Is Not Null Then
      Update Interest_Calc I
         Set I.Is_Close = 'T'
       Where I.Object_Id = P_Object_Id
         And I.Is_Close = 'F'
         And I.Calc_Date >= P_Begin_Date
         And I.Calc_Date < P_End_Date + 1
         And I.Calc_Type In
             ('EXPIRE_R_FOR_MACRO_CRED', 'INT_PART_EXPIRE_CRED');
      P_Base_Action.Notify_Action_Desc_FMT('Календарь начислений на просроченную часть тела закрыт c %s по %s',
                                           P_Begin_Date,
                                           P_End_Date);
    End If;
  End;

  -- madcap
  --проверка на  наличии "0" остатков на всех счетах, подвязанных к договору, за исключением счета CUSTOMER_ACCOUNT.
  procedure cred_close_after_gen(P_Template_Id       In Generator_Template.id%type,
                                 P_Additional_Params In Varchar2) is
    cursor get_acc(p_compound_document_id compound_document.id%type) is
      select gam.sys_name, acc.account_number, acc.amount
        from contract_account cac,
             account          acc,
             --balance_account ba,
             contract_acc_macro  cam,
             generator_acc_macro gam
       where cac.contract_id = p_compound_document_id
         and cac.is_common = 'F'
         and acc.id = cac.account_id
         and acc.amount > 0
         and cac.macro_id = cam.id
         and cam.macro_id = gam.id
         and
            --acc.balance_id=ba.id and
            --ba.code<>'2600' and
             gam.sys_name <> 'CUSTOMER_ACCOUNT';
  
    l_get_acc get_acc%rowtype;
    mes       varchar2(500);
  
  begin
  
    for l_get_acc in get_acc(p_base_action.get_current_comp_doc_id) loop
      mes := mes || chr(13) || l_get_acc.sys_name || ' - ' ||
             to_char(l_get_acc.account_number) || ' = ' ||
             to_char(l_get_acc.amount);
    end loop;
  
    if mes is not null then
      p_exception.raise_common_except('На счетах договора наличие ненулевых остатков!!!' || mes);
    end if;
  end;
  --ams согласно СЗ № 7.3-10/953 от 08.10.2008
  Procedure On_Before_Close_Doc(P_Template_Id       In Generator_Template.Id%Type,
                                P_Additional_Params In Varchar2) Is
    Cursor Get_Oper_Date(P_Contr_Id Number, P_Oper_Name Varchar2) Is
      Select CA.Post_Date
        From Compound_Action CA, Operation O
       Where CA.Compound_Document_Id = P_Contr_Id
         And O.Id = CA.Operation_Id
         And O.Code = P_Oper_Name
       Order By CA.Post_Date;
    L_Yes_Oper_Date     Date;
    L_Not_Oper_Date     Date;
    L_Additional_Params Varchar2(2048);
    Cursor Get_Acc(P_Compound_Document_Id Compound_Document.Id%Type) Is
      Select Sum(Acc.Amount) Amount
        From Contract_Account    Cac,
             Account             Acc,
             Contract_Acc_Macro  Cam,
             Generator_Acc_Macro Gam
       Where Cac.Contract_Id = P_Compound_Document_Id
         And Cac.Is_Common = 'F'
         And Acc.Id = Cac.Account_Id
         And Acc.Amount <> 0
         And Cac.Macro_Id = Cam.Id
         And Cam.Macro_Id = Gam.Id
         And Gam.Sys_Name <> 'CUSTOMER_ACCOUNT';
    L_Get_Acc Get_Acc%RowType;
  Begin
    L_Additional_Params := P_Additional_Params;
    --получим дату выполнения операции разрешения начисления %
    L_Yes_Oper_Date := Null;
    Open Get_Oper_Date(P_Base_Action.Get_Current_Comp_Doc_Id,
                       'CRED_CHARGE_INTEREST');
    Fetch Get_Oper_Date
      Into L_Yes_Oper_Date;
    Close Get_Oper_Date;
    --получим дату выполнения операции запрета начисления %
    L_Not_Oper_Date := Null;
    Open Get_Oper_Date(P_Base_Action.Get_Current_Comp_Doc_Id,
                       'CRED_NOT_CHARGE_INTEREST');
    Fetch Get_Oper_Date
      Into L_Not_Oper_Date;
    Close Get_Oper_Date;
    If (L_Not_Oper_Date Is Not Null) And
       ((L_Yes_Oper_Date Is Null) Or (L_Yes_Oper_Date < L_Not_Oper_Date)) And
       (P_Interest.Get_Min_Open_Date(P_Base_Action.Get_Current_Comp_Doc_Id,
                                     'CREDIT') >= L_Not_Oper_Date) Then
      --если есть дата выполнения операции запрета начисления И
      --(если операция разрешения начисления % не выполнялась ИЛИ дата этой операции меньше даты операции запрета начисления) И
      --в календаре незакрыты дни после даты выполнения операции запрета начисления %
      --делаем подмену строки доппараметров, чтобы не проходила проверка незакрытых дней в календаре
      L_Additional_Params := L_Additional_Params || Chr(13) || Chr(10) ||
                             'CHECK_DAYS#BOOL#Проверять незакрытые дни в календаре#F';
    Else
      L_Get_Acc := Null;
      Open Get_Acc(P_Base_Action.Get_Current_Comp_Doc_Id);
      Fetch Get_Acc
        Into L_Get_Acc;
      Close Get_Acc;
      If (L_Get_Acc.Amount Is Null) Or (L_Get_Acc.Amount <= 0) Then
        L_Additional_Params := L_Additional_Params || Chr(13) || Chr(10) ||
                               'CHECK_DAYS#BOOL#Проверять незакрытые дни в календаре#F';
      End If;
    End If;
    D_Credit_Generator.On_Close_Doc(P_Template_Id, L_Additional_Params);
  End;
  --end ams

  End;                                                     
End FC_CRED_PROCEDURES;

</pre>
</html>
